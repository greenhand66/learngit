
/* Logging control, set these to non-zero to enable output */
#define ERROR_LOG		(1)
#define INFO_LOG		(0)

#if ERROR_LOG
#define ERROR_PRINTF   dbg_printfSync("[ERR][vi_app_uf][%s][%d] ",__FUNCTION__,__LINE__),(void)dbg_printfSync
#else
static INLINE void ERROR_PRINTF(const char *fmt, ...) {}
#endif

#if INFO_LOG
#define INFO_PRINTF   dbg_printfSync("[INF][vi_app_uf][%s][%d] ",__FUNCTION__,__LINE__),(void)dbg_printfSync
#else
//static INLINE void INFO_PRINTF(const char *fmt, ...) {}
#endif

// IMRチャンネルNo
#define D_VI_IMRLSX_UF_CH	(3)

/* アライメント定義 */
#define VI_ALING_32( w )			( ( 0 == ( (w) % 32 ) ) ? (w) : ( ( (w) / 32 + 1 ) * 32 ) )


/* デドレコ情報保存数 */
#define D_VI_SAVE_RECKON_MAX	(5)

/* DEBUG */
/* 空きアドレス (2.7MByte 21セクタ） */
#define E_UF_ADDR_RESERVED_ZONE_P (E_CMN_ROMADDR_RESERVED1)//add No762
#define E_UF_RESERVED_SECTOR_NUM 21//add No762
	
/**
 * @brief	矩形領域の定義
 */
enum {
	D_VI_UF_RECT_LT = (0),	// 左上
	D_VI_UF_RECT_RT,		// 右上
	D_VI_UF_RECT_LB,		// 左上
	D_VI_UF_RECT_RB,		// 右下
	D_VI_UF_RECT_MAX,		// 最大値
};

#define E_VI_UF_OFFSET_FR 		1.0F	/* 車両サイズからのOFFSET  前後方向 1m分 */
#define E_VI_UF_OFFSET_SIDE		1.0F	/* 車両サイズからのOFFSET  左右方向 1m分 */

#define		CMN_DEG2RAD_F_F32(x)		(F32)((F32)(x) * 0.01745329252F)

#define	CMN_F32ABSROUND(x)	(((F32)x < 0.0F) ? ((F32)x-0.5F) : ((F32)x+0.5F))
#define	HIST_UNDER_START_X_LHD		204		/* ヒストグラム用 開始 X */
#define	HIST_UNDER_START_Y_LHD		217		/* ヒストグラム用 開始 Y */
#define	HIST_UNDER_END_X_LHD		312		/* ヒストグラム用 終了 X */
#define	HIST_UNDER_END_Y_LHD		508		/* ヒストグラム用 終了 Y */
#define	HIST_UNDER_START_X_RHD		968		/* ヒストグラム用 開始 X */
#define	HIST_UNDER_START_Y_RHD		217		/* ヒストグラム用 開始 Y */
#define	HIST_UNDER_END_X_RHD		1076	/* ヒストグラム用 終了 X */
#define	HIST_UNDER_END_Y_RHD		508		/* ヒストグラム用 終了 Y */

#define E_VI_UF_BU_FRAME_MAX	13			/* cxee through view backup frame num */
#define E_VI_UF_H	1.2F	/*uf height*/		

#define E_RCMM_INDEX_MAX (10)

#define SKELETON_VIEW_BLINK_TIME (600U)  /* Not Live icon blink timer */


/******************************************************************
 * 構造体宣言
 ******************************************************************/
typedef struct
{
	membmp_id_t mem_id;
	void *virt_addr;
	uint32_t phy_addr;
} S_VI_UF_MEM_ITEM_T;

typedef struct
{
	uint32_t buf_num;
	uint32_t curr_buf_index;
	uint32_t next_buf_index;
	uint32_t uv_offset;

	membmp_info_t mem_info;
	S_VI_UF_MEM_ITEM_T mem_item[E_VI_RGB_FRAME_MAX];
} S_VI_UF_BUF_T;

typedef struct
{
	int32_t				imr_ch;
	T_IMRLSDRV_SOURCE	imr_src;
//	r_imr_data_t	imr_src_data;
//	r_imr_data_t	imr_dst_data;
} S_VI_IMR_PARAM_TBL;

typedef struct {
	/* 後輪車軸中心の位置情報 */
	slong		vp_rear_wpos_x;							/* 自車世界座標[1cm] */
	slong		vp_rear_wpos_y;							/* 自車世界座標[1cm] */
	slong		vp_rear_angle;							/* 自車角度[0.1deg] */

	float_t		trip;									/* 距離積算値[cm] */
	SYSTIM		tim;									/* タイムスタンプ */
	float_t		steering_angle;							/* 操舵角[deg] */
	float_t		vehicle_speed;							/* 車速[km/h] */
	float_t		wspeed_r_re;							/* 右リア車輪速[rpm] */
	float_t		wspeed_l_re;							/* 左リア車輪速[rpm] */
	float_t		wspeed_r_fr;							/* 右フロント車輪速[rpm] */
	float_t		wspeed_l_fr;							/* 左フロント車輪速[rpm] */
	ushort		pls_r_re;								/* 右後輪車輪速パルス */
	ushort		pls_l_re;								/* 左後輪車輪速パルス */
	float_t		rot_radius;								/* 回転半径[mm] */
} S_VI_UF_DEADREC_INFO;

typedef struct {
	/* 後輪車軸中心の位置情報 */
	slong		vp_rear_wpos_x;							/* 自車世界座標[1cm] */
	slong		vp_rear_wpos_y;							/* 自車世界座標[1cm] */
	slong		vp_rear_angle;							/* 自車角度[0.1deg] */
	float_t		steering_angle;							/* 操舵角[deg] */
	float_t		trip;									/* 距離積算値[cm] */	
	SYSTIM      Time;
} S_VI_UF_DEADREC_INFO_SIMPLE;

/* --< バッファサイズ >------------------------------- */
#define E_VI_UF_DEADREC_BUFSIZE		10	/* デッドレコニング情報のバッファサイズ */
/* ---< @@ デッドレコニング履歴情報構造体 @@ >--- */
typedef struct {
	uchar					buf_size;				/* 配列数 */
	uchar					rw_point;				/* 最新配列要素添字 */
	S_VI_UF_DEADREC_INFO	deadrec_info[E_VI_UF_DEADREC_BUFSIZE];	/* デッドレコニング配列 */
} S_VI_UF_DEADREC_INFO_BUF;

// throughview backup
typedef struct
{
	uint32_t buf_num;
	uint32_t curr_buf_index;		// backup index
	uint32_t next_buf_index;		// backup next index
	uint32_t uv_offset;
	uint32_t index_captured;		// front caemra captured index
	uint32_t index_backup_3h;		// backup index for hoodview 
	S_VI_UF_DEADREC_INFO_SIMPLE curDeadFR[E_VI_VIN_CAP_BUF_NUM];
	
	membmp_info_t mem_info;
	S_VI_UF_MEM_ITEM_T mem_item[E_VI_UF_BU_FRAME_MAX];				// through view 
	S_VI_UF_DEADREC_INFO_SIMPLE deadrec_info[E_VI_UF_BU_FRAME_MAX];	// deadreco
	uchar camera_id[E_VI_UF_BU_FRAME_MAX];							// camera dir
	uchar first_cycle_cnt;											//record the first cycle buffer uesd status
} S_VI_UF_BU_BUF_T;

typedef struct
{
	S_VI_UF_BUF_T		out_plane_buf;
	//S_VI_UF_BUF_T		out_plane_bufSub;//add No762
	S_VI_UF_BUF_T		out_alpha_plane_buf;
	//S_VI_UF_BUF_T		out_alpha_plane_dummy_buf;
	S_VI_UF_BU_BUF_T	through_plane_buf;
	S_VI_IMR_PARAM_TBL	imr_param;
	
	uchar				handle;
	
	ID					dl_id;
	ID					dl_id_sub;//dual DL No762
	ID					dl_id_bu;// cxee through view backup
	ulong				*oddYUVaddr;
} S_VI_APP_UF_TBL_T;


/* デドレコ移動値計算用情報 */
typedef struct
{
	double_t	pos_x;
	double_t	pos_y;
	double_t	sin_yaw;
	double_t	cos_yaw;
} S_VI_UF_POS;


typedef struct
{
	/* 座標 */
	slong			s32_x;
	slong			s32_y;
} S_VI_UF_PointWorld;

/* バックアップ */
#define DISP_W 1280
#define DISP_H 720
	
typedef struct {
	uchar backup_id[8];
	ushort w;	//幅
	ushort h;	//高
	sshort startX;	//始点X座標
	sshort startY;	//始点Y座標
} VI_S_BACKUPDATAHEAD;

typedef struct {
	VI_S_BACKUPDATAHEAD head;
	uchar  data[2];
} VI_S_BACKUPDATA;

static VI_S_BACKUPDATA *s_backupData;
static VI_S_BACKUPDATAHEAD save_head;
static uchar workBuf[200000];
static uchar backup_id[8] = {0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18};
static uchar g_isDispBufValid = FALSE;

sint g_hood_view_capture_threshold_low = 340;  //Add limit to avoid front camera blind spot, used for skeleton view
sint g_hood_view_capture_threshold_high = 380;  //Add limit to avoid front camera blind spot, used for skeleton view


/******************************************************************
 * static関数プロトタイプ宣言
 ******************************************************************/
static ushort vi_uf_main( void );

static S_VI_UF_MEM_ITEM_T* vi_app_uf_GetNextBufItem(S_VI_UF_BUF_T *pBuf);
static S_VI_UF_MEM_ITEM_T* vi_app_uf_SetAndGetCurrBufItem(S_VI_UF_BUF_T *pBuf);
static S_VI_UF_MEM_ITEM_T* vi_app_uf_GetCurrBufItem(S_VI_UF_BUF_T *pBuf);
//static membmp_id_t vi_app_uf_GetNextBufId(S_VI_UF_BUF_T *pBuf);
static membmp_id_t vi_app_uf_GetCurrBufId(S_VI_UF_BUF_T *pBuf);
static slong vi_app_uf_BlendProc( void );
static slong vi_app_uf_BlendProc_2( void );//add No762
static slong vi_app_uf_LocalInit( void );
static slong vi_app_uf_SetupBuf(S_VI_UF_BUF_T *pBuf, uint32_t buf_num);
static slong vi_app_uf_vi_MakeImage(membmp_id_t in_mem_id, S_VI_UF_MEM_ITEM_T *pItem);
static slong vi_app_uf_vi_MakeImage_2(membmp_id_t in_mem_id, S_VI_UF_MEM_ITEM_T *pItem);//add No762
static slong vi_app_uf_UpdateDl( void );
static slong vi_app_uf_vi_MakeAlpha( void );

static slong vi_app_uf_InitImr( int32_t imr_ch, S_VI_IMR_PARAM_TBL *pImr );

//static void vi_app_uf_DumpRect( T_IMRLIB_RECT *rct );
//static void vi_app_uf_DumpDl( ER_ID dl_id );
static slong vi_app_uf_GetLayout( void );
static slong vi_app_uf_GetLayout_VEHICLE(T_IMRLIB_RECT *rect, const S_VI_LAYOUT_DATA *layout, uchar handle);
#if 0
//add No762
slong vi_app_uf_bc_regset( void );
#endif

static void vi_app_uf_MakeSrcCoord( void );
static slong vi_app_uf_InitMakeArea( S_VI_CAR_COMMON_PARAM_TBL *car_add );
static void vi_app_uf_calcPos( const S_VI_F_COORDINATE * in_pnt, S_VI_F_COORDINATE * out_pnt, const S_VI_UF_POS * pos );
static slong vi_app_uf_convert_ScreenCoord( S_VI_F_COORDINATE *inCoord, S_VI_F_COORDINATE *outCoord, const S_VI_CAR_COMMON_PARAM_TBL *car_add );
static slong vi_app_uf_adapt_InitArea(S_VI_F_COORDINATE *point, 	slong x_max, slong y_max);


/* デバッグ描画関連 */
static slong vi_app_uf_DebugUF( const S_VI_TBL_DATA *apTbl , const S_VI_F_COORDINATE * psrc_rect, const S_VI_F_COORDINATE * pdst_rect);
static slong vi_app_uf_DebugRect( const S_VI_F_COORDINATE *rect, struct_MM_Data_View_Debug_Info *p_drawData, ulong color, uchar width);

/* 座標変換関連 */
static slong vi_app_uf_deadrecinfo(S_VI_UF_DEADREC_INFO_BUF *s_drec_info);
slong vi_app_uf_CalcMyRect( const S_VI_F_COORDINATE* src_local_pnt, const S_VI_UF_DEADREC_INFO* drec, const S_VI_UF_DEADREC_INFO* drec_pre, S_VI_F_COORDINATE* src_local_conv_pnt);
slong vi_app_uf_Math_CalcRotatePoint( const S_VI_F_COORDINATE* ptOrigin_pnt, const S_VI_F_COORDINATE* ptIn_pnt, float_t fAngle, S_VI_F_COORDINATE* ptOut_pnt );
void vi_app_uf_Math_WldToLoc_point(S_VI_F_COORDINATE *Wld_pnt, const S_VI_UF_DEADREC_INFO *deadrec, S_VI_F_COORDINATE *Loc_pnt);
static slong vi_app_uf_ConvRcglocToViewloc( const S_VI_F_COORDINATE *rcgloc, S_VI_F_COORDINATE *srcloc);

/* No762DEBUG */
static void vi_app_uf_makeDSTRectBySRC(S_VI_F_COORDINATE *dst, S_VI_F_COORDINATE *src, S_VI_F_COORDINATE *out);
static float_t vi_app_uf_GetAngle(S_VI_F_COORDINATE *toCoord, S_VI_F_COORDINATE *fromCoord);
static float_t vi_app_uf_GetDistance(S_VI_F_COORDINATE *toCoord, S_VI_F_COORDINATE *fromCoord);
//static void vi_app_uf_DebugSRC(S_VI_F_COORDINATE *dst, S_VI_F_COORDINATE *src, S_VI_F_COORDINATE *out);

static slong vi_app_uf_backup( void );//add No762
 static slong vi_app_uf_backup_mem( void );//add No762
static slong vi_app_uf_flEraseSect( ulong );//add No762
static slong vi_app_uf_BackupRead( void );//add No762
static slong vi_app_uf_BackupDisp( void );//add No762
static float_t vi_app_uf_GetSpeed( void );//add No762

static void CopyReadBugToBackUpBuf(uchar *startAdr, uchar *cporg, ushort w, ushort h, ushort x, ushort y);
static void CopyReadBuf(uchar *virt_addr, VI_S_BACKUPDATA *dt);
static void CopyBackUpBufToWriteBug(VI_S_BACKUPDATA *dt, uchar *orgAdr, uchar *cpAdr);
static void CopyBackUpBuf(uchar *dispBuf, VI_S_BACKUPDATA *writeBuf );
void  vi_app_uf_RecSkeltonViewCoord(void);
void vi_app_uf_Set_IGNON( void );
void vi_app_Stop_UfBackup_IGN_Flag( void );
float_t vi_app_uf_Getvehicle_speed( void );
char* vi_app_uf_GetName( void );


/******************************************************************
 * static変数宣言
 ******************************************************************/
static S_VI_APP_UF_TBL_T vi_app_uf_tbl;
static S_VI_APP_UF_TBL_T *pUft;


static S_VI_F_COORDINATE SrcLocalCoord[D_VI_UF_RECT_MAX];	/* 俯瞰映像SRC相対座標 */
static S_VI_F_COORDINATE SrcScreenCoord[D_VI_UF_RECT_MAX];	/* 俯瞰映像SRC画面座標 */
static S_VI_F_COORDINATE DstScreenCoord[D_VI_UF_RECT_MAX];	/* 俯瞰映像DST画面座標 */
static S_VI_F_COORDINATE RcgLocalCoord[D_VI_UF_RECT_MAX];	/* 画像認識向けSRC相対座標 */


/* No762DEBUG */
static S_VI_F_COORDINATE SrcScreenCoord_DEBUG[D_VI_UF_RECT_MAX];	/* 俯瞰映像SRC画面座標 デバッグ用*/
static S_VI_F_COORDINATE DstScreenCoord_DEBUG[D_VI_UF_RECT_MAX];	/* 俯瞰映像DST画面座標 デバッグ用 */

//static struct_MM_Data_Deadrecog ReckOnData[D_VI_SAVE_RECKON_MAX];	/* デドレコ情報保存配列 */
//static schar ReckOnData_WritePoint;									/* デドレコ情報保存書き込みポインタ */
static S_VI_UF_DEADREC_INFO_BUF	s_drec_info;
static S_VI_UF_DEADREC_INFO		s_drec_info_pre;			/* デッドレコニングの前回値 */


/* 状態 *///add No762
enum {
	UF_IGN_TASK_START = (0),	/* タスクスタート  */
	UF_IGN_TASK_INIT,			/* タスク初期化完了*/
	UF_IGN_ON_RECV,				/* IGNON受信  */
	UF_IGN_DRIVE,				/* 運転中  */
	UF_IGN_STOP,				/* 停止 */
	UF_IGN_MAX,					/* 最大値 */
};

#define UF_BACKUP_START_SPEED	(3.0F)	/* バックアップ開始速度 */
#define UF_DRIVE_SPEED	(0.001F)		/* 走行速度 */
#define UF_FLASH_SECTOR_SIZE (128000U)	/* FLASH 1セクタサイズ */

static uchar UfBackup_IGN_Flag =  UF_IGN_TASK_START;	/* 状態フラグ*/
static float_t m_save_speed = 0.0F;	/* 車速保存 */

/******************************************************************
 * extern変数宣言
 ******************************************************************/
extern ID m_vi_event_flg_uf;
extern T_VI_VSP_PARAM_MAIN m_vi_VspParamMain;
//extern T_VI_VSP_PARAM_MAIN m_vi_VspParamSub;//add No762
extern uchar m_vi_disp_pattern;
/* デバッグ用：輝度値（固定）0:実値 1:暗 2:明 add No762 */
extern slong m_vi_bright_mode;

extern T_IMRLIB_DL * imrlib_getDLInf(ID dl_id);

/* No762DEBUG */
sshort uf_debug_xyflag = 0;
sshort uf_debug_xyVal = 0;
sshort uf_debug_WAdd = 0;
sshort uf_debug_XAdd = 0;
sshort uf_debug_YAdd = 0;
schar uf_debug_DispUpdate = 1;			//33ms * N
//schar uf_debug_DispUpdate = 1;			//No762 Test
sshort dbg_wpos_x_before = 0;
sshort dbg_wpos_y_before = 0; 
sshort dbg_angle_before = 0;
sshort dbg_wpos_x_after = 0;
sshort dbg_wpos_y_after = 0;
sshort dbg_angle_after = 0; 
sshort debug_45flag = 1;				//四捨五入
float_t uf_vehicle_speed_dbg = 0.0;		//車速 add No762

// debug flag 20210311
enum 
{
	DBG_FLG_DEADRECO = 0,
	DBG_FLG_SRC_COORD,
	DBG_FLG_DST_COORD,
	DBG_FLG_FINAL_COORD,
	DBG_FLG_MAX
};
slong  uf_debug_flag[DBG_FLG_MAX] = {0};
	
static T_IMRLIB_2DPOS pt_src_DEBUG[D_VI_UF_RECT_MAX];
static T_IMRLIB_2DPOS pt_dst_DEBUG[D_VI_UF_RECT_MAX];

// throughview backup
#define E_UF_ADDR_TRANSPARENT_MAP	E_MAP_ADDR_3D_TRANSPARENT_HOOD//E_MAP_ADDR_THROUGH_MIRROR_PROG	
#define D_UF_MAP_POS_MAX 	( ( E_VI_CAMERA_LAYOUT_WIDTH_MAX / E_VI_CAM_DL_PITCH_X + 1 ) * ( E_VI_CAMERA_LAYOUT_HEIGHT_MAX / E_VI_CAM_DL_PITCH_Y + 1 ) )

#define D_UF_3H_DST_X_PITCH		7		/* X direction point num */
#define D_UF_3H_DST_Y_PITCH		7		/* Y direction point num */
#define D_UF_3H_DST_NUM			(D_UF_3H_DST_X_PITCH*D_UF_3H_DST_Y_PITCH)

//#define	D_UF_3H_DST_R_DIST		0.27f		/* margin from front wheel center in rear direction */
//#define	D_UF_3H_DST_F_DIST		0.07f		/* margin from front bumper point in front direction */

#define D_UF_3H_BU_DIST			25.0f		/* backup throughview when the trip forward x distance unit:cm  */

#define D_UF_SKELTON_BLEND_PIXEL_OFFSET 2U	/* Pixel offset value used for blending processing in hood area */

static slong vi_app_uf_loadMapFlash_BU();
static slong vi_app_uf_SetupBUBuf(S_VI_UF_BU_BUF_T *pBuf, uint32_t buf_num);
static slong vi_app_uf_ThroughviewBackup( void );
static uchar vi_app_uf_GetShiftPositon(void);
static slong vi_app_uf_MakeSrcCoord_3h( void );
static slong vi_app_uf_CompensationScreen(S_VI_F_COORDINATE* src_local_cnv_pnt, uint32_t* index_backup, const S_VI_UF_DEADREC_INFO_SIMPLE* drec, const S_VI_UF_DEADREC_INFO_SIMPLE* drec_pre);
static int vi_app_uf_PointInPolygon(int nvert, double *vertx, double *verty, double testx, double testy);
static slong vi_app_uf_IsInAvaiableArea(S_VI_UF_DEADREC_INFO_SIMPLE* pSrc , S_VI_UF_DEADREC_INFO_SIMPLE* pCoord , int i);
static slong vi_app_uf_GetLayout_3h( void );
static slong vi_app_uf_clearImage( ID mem_bmp_id, ulong val );
slong vi_app_uf_CalcMyRect_3h( const S_VI_F_COORDINATE* src_local_pnt, const S_VI_UF_DEADREC_INFO_SIMPLE* drec, const S_VI_UF_DEADREC_INFO_SIMPLE* drec_pre, S_VI_F_COORDINATE* src_local_conv_pnt);

extern int32_t *d_vin_ch_array;									/* vin channel array */
//static T_IMRLIB_2DPOS map_3h[D_UF_MAP_POS_MAX];
static T_IMRLIB_2DPOS map_3h[D_VI_MAP_POS_MAX];
static ID m_vi_event_BU;										/* through view backup event id */
static S_VI_F_COORDINATE SrcScreenCoord_3h[D_UF_3H_DST_NUM];	/* 3d hoodview SRC座標 */
static S_VI_F_COORDINATE DstScreenCoord_3h[D_UF_3H_DST_NUM];	/* 3d hoodview DST座標 */
static S_VI_F_COORDINATE RcgLocalCoord_3h[D_UF_3H_DST_NUM];		/* 3d hoodview 画像認識向けSRC相対座標 */
static S_VI_F_COORDINATE DstScreenCoord_3h_ori[D_UF_3H_DST_NUM];	/* 3d hoodview DST coordinate before expand */

extern uchar *p_blend_data_01_fr;         //the pointer to front camera and skelton view blending MAP data
extern uchar *p_blend_data_01_side;       //the pointer to left/right camera and skelton view blending MAP data

//Single skelton view edge point screen coordinates
T_IMRLIB_2DPOS skelton_view_lt = {0, 0};  //skelton view area left top point
T_IMRLIB_2DPOS skelton_view_lb = {0, 0};  //skelton view area left bottom point
T_IMRLIB_2DPOS skelton_view_rt = {0, 0};  //skelton view area right top point
T_IMRLIB_2DPOS skelton_view_rb = {0, 0};  //skelton view area right bottom point

T_IMRLIB_2DPOS skelton_view_lt_ori = {0, 0};  //skelton view area left top point(before expand)
T_IMRLIB_2DPOS skelton_view_lb_ori = {0, 0};  //skelton view area left bottom point(before expand)
T_IMRLIB_2DPOS skelton_view_rt_ori = {0, 0};  //skelton view area right top point(before expand)
T_IMRLIB_2DPOS skelton_view_rb_ori = {0, 0};  //skelton view area right bottom point(before expand)

static slong compensation_alg_choose = 0;
int skelton_debug_flg = 0;
double_t skelton_yoko_keisu_AAA = 0.000f;
double_t skelton_debug_param = 0.0;//-8.0;//-12.5;
double_t skelton_yoko_start_deg = 0.0f;
double_t skelton_yoko_keisu_AAA_left =  0.000f;//0.150f;
double_t skelton_yoko_keisu_AAA_right = 0.000f;//0.150f;
/* Compensation mode switch: 
* 1 -- means using coefficient compensation; 
* 0 -- means using angle compensation 
*/
static slong code_switch = 1;  
/* Angles that need to be compensated in different rudder angle ranges. 50 degrees is an interval. */
static float_t compensation_angle[8] = {0.23, 0.48, 0.76, 1.09, 1.46, 1.89, 2.52, 3.64};
static S_VI_UF_POS pos_rot = {
	0.0,
	0.0,
	0.0,
	0.0,
};
static float_t step_scale_angle = 0.01;     /* Angle Compensation modulus */
static slong rotate_center_switch = ((D_UF_3H_DST_NUM) / 2);    /* Angle Compensation Rotation Center */
static S_VI_F_COORDINATE SrcScreenCoord_3h_pre[D_UF_3H_DST_NUM] = {0};    /* 3d hoodview previous source screen coordinates */
static S_VI_F_COORDINATE SrcScreenCoord_3h_correct_pre[D_UF_3H_DST_NUM] = {0};    /* 3d hoodview previous source screen coordinates after corrected */
static float_t step_scale_x = 1.00;
static float_t step_scale_y = 1.00;

extern uchar NotLiveBlinkCnt;
extern slong vi_app_SetSkeletonBlinkTimer(T_VI_TIMER_TBL *pTmr,  slong override);
extern T_VI_TIMER_TBL  SkeletonNotLiveTimer;

/* use for the skeleton mask setting */
extern S_VI_SKELETON_VIEW_LAYOUT				m_vi_skeleton_blend_frline_layout;
extern S_VI_SKELETON_VIEW_LAYOUT				m_vi_skeleton_blend_sideline_layout;
void vi_app_set_skeleton_mask();
static slong vi_app_nosig_mask_set_quadrilateral( uchar index, const S_VI_COORDINATE *p_fl_pos,const S_VI_COORDINATE *p_fr_pos, const S_VI_COORDINATE *p_rr_pos, const S_VI_COORDINATE *p_rl_pos);

//extern T_IMRLIB_2DPOS *d_vi_dst_local_buf[D_VI_MAP_POS_MAX]; /* タイル化のためあらかじめDist側の座標を格納しておく */

//static float_t m_vi_vehicle_angle = 300.0F;	/* 30deg */

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_init
 * 機能        UFタスク関連変数の初期化
 * 引数        なし
 * 戻り値      slong
 * 作成日      2018/05/15
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 *
 * 出力        なし
 *
 *==============================================================================================
_FCHK_*/
slong vi_app_uf_init( void )
{
	T_CTSK		ctsk = {0};
	ER			ercd;

	pUft = &vi_app_uf_tbl;
	memset( (void *)pUft, 0x00, sizeof(S_VI_APP_UF_TBL_T) );

	// DLは未作成状態。
	pUft->dl_id = E_VI_MALLOC_FAILURE;
	pUft->dl_id_sub = E_VI_MALLOC_FAILURE;//dual DL No762

	/* 車両下映像のプレーン生成タスクを作成 */
	ctsk.tskatr		= ( TA_HLNG | TA_COP1 );	/* 属性: 高級言語,生成時起動,FPU-0使用 */	//★TA_COP1も？
	ctsk.exinf		= 0;
	ctsk.itskpri	= E_VIEW_PLANE_UF_PRIORITY;
	ctsk.stksz		= E_VIEW_PLANE_UF_STACK_SIZE;
	ctsk.stk		= NULL;		/* 領域: ダイナミックスタック領域指定 */
	ctsk.task		= (FP)&vi_uf_main;			// MISRA-Cからの [EntryAVM_QAC#1] R2.7.1_(1) (2)  R-105, ID-10842

	ercd = cl_cre_tsk( VIEW_PLANE_UF_TASK, &ctsk );
	if( E_OK != ercd )
	{
		/* 作成失敗 */
		ERROR_PRINTF("\n");
	}
	ercd = cl_act_tsk( VIEW_PLANE_UF_TASK );
	if( E_OK != ercd )
	{
		/* 起動失敗 */
		ERROR_PRINTF("\n");
	}

	/* バックアップ */
	s_backupData = (VI_S_BACKUPDATA *)workBuf;

	return E_VI_SUCCESS;
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_uf_main
 * 機能        車両下映像タスク
 * 引数        なし
 * 戻り値      ushort
 * 作成日      2018/05/15
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 *
 * 出力        なし
 *
 *==============================================================================================
_FCHK_*/
static ushort vi_uf_main( void )
{
	ER			ercd;
	FLGPTN		wai_flgptn = 0u;
	FLGPTN		wai_ptn = 0u;
	float_t speed;//add No762
	slong eret;//add No762
	S_VI_UF_BU_BUF_T* pBuf = &pUft->through_plane_buf;

	/* backup event flag */
	m_vi_event_BU = D_VI_FLG_FR_FRAME_UPDATE;
	
	/* 状態にスクスタート設定 */
	UfBackup_IGN_Flag = UF_IGN_TASK_START;//add No762

	(void)vi_app_uf_LocalInit();

	/* 状態に初期化完了 */
	UfBackup_IGN_Flag = UF_IGN_TASK_INIT;//add No762
	
	while( 1 )
	{		
		wai_ptn = /*(D_VI_FLG_UPDATE_DL | D_VI_FLG_UPDATE_DL_MEM | D_VI_FLG_BLEND_COMPLETE |*/ m_vi_event_BU;
		/* イベント待ち(100msecタイムアウト) */
		ercd = cl_twai_flg( m_vi_event_flg_uf, wai_ptn, TWF_ORW, &wai_flgptn, 100 );
		if( E_TMOUT == ercd )
		{
			// タイムアウト
			//Judge whether the front camera signal is interrupted
			if( E_VI_VSYNC_NO_SIGNAL == d_vin_vsync_pre_status[d_vin_ch_array[D_VI_VIN_CH_FRONT]] )
				{
					pBuf->first_cycle_cnt = 0U;
					NotLiveBlinkCnt = 0U;
					
				}
			else
				{
					//do nothing;
				}
			
        	continue; 
		}
		else if( E_OK != ercd )
		{
			/* エラーログ */
			ERROR_PRINTF("\n");
			continue;
		}

		/* フラグをクリア */
		// warning対応、および本関数高速化のため、戻り値の取得＆確認を省略する
		(void)cl_clr_flg( m_vi_event_flg_uf, ~wai_flgptn );

		{
			//add No762 start
			/* IGNON受信 */
			if( UF_IGN_ON_RECV == UfBackup_IGN_Flag)
			{
				/* 自車下透過バックアップデータ表示 */
				vi_app_uf_BackupDisp();
			}
			/* 自車下透過バックアップデータ表示でUfBackup_IGN_Flag = UF_IGN_STOPで
			 * バックアップデータの表示を継続させる
			 * UF_IGN_STOP以降、車速が入った場合にUF_IGN_DRIVEにして自車下透過を開始する、
			 * UF_IGN_DRIVEになった後は車速0でもUF_IGN_DRIVEのままとする
			 */
			/* IGNON受信後メモリ読み込みで、車速ありを判定 */
			if( UF_IGN_STOP == UfBackup_IGN_Flag)
			{
				speed = vi_app_uf_GetSpeed();
				if( speed > UF_DRIVE_SPEED )
				{
					dbg_printfSync("[View]##### vi_uf_main speed = %f \n", speed);
					/* 状態に運転中を設定 */
					UfBackup_IGN_Flag = UF_IGN_DRIVE;
				}
			}
		}

		if( E_VI_PRM_3D_OVM_VIEW1 == m_vi_disp_pattern )
		{
			/* 自車下透過 */
			vi_app_uf_UpdateDl();
			vi_app_uf_BlendProc();
		}

		if( 0 != ( wai_flgptn & m_vi_event_BU ))
		{
			(void)vi_app_uf_ThroughviewBackup();
		}

	} // while loop
}


static S_VI_UF_MEM_ITEM_T* vi_app_uf_GetNextBufItem(S_VI_UF_BUF_T *pBuf)
{
	pBuf->curr_buf_index = pBuf->next_buf_index;
	pBuf->next_buf_index = ( pBuf->next_buf_index + 1 ) %  pBuf->buf_num;

	return &pBuf->mem_item[pBuf->curr_buf_index];
}

static S_VI_UF_MEM_ITEM_T* vi_app_uf_SetAndGetCurrBufItem(S_VI_UF_BUF_T *pBuf)
{
	pBuf->curr_buf_index = pBuf->next_buf_index;

	return &pBuf->mem_item[pBuf->curr_buf_index];
}

static S_VI_UF_MEM_ITEM_T* vi_app_uf_GetCurrBufItem(S_VI_UF_BUF_T *pBuf)
{
	return &pBuf->mem_item[pBuf->curr_buf_index];
}

static membmp_id_t vi_app_uf_GetCurrBufId(S_VI_UF_BUF_T *pBuf)
{
	S_VI_UF_MEM_ITEM_T *pItem = vi_app_uf_GetCurrBufItem(pBuf);

	return pItem->mem_id;
}

static slong vi_app_uf_BlendProc( void )
{
	T_VI_VSP_PARAM_MAIN *pVsp = &m_vi_VspParamMain;
	//T_VI_VSP_PARAM_MAIN *pSub = &m_vi_VspParamSub;//add No762
	membmp_id_t in_m_id, out_a_m_id;
	membmp_id_t out_a_s_id;//add No762
	S_VI_UF_MEM_ITEM_T *pItem;
	//S_VI_UF_MEM_ITEM_T *pItemSub;//add No762
	uint32_t index;
	//struct_MM_Data_View_Hist_Under_Param	Hist_under;//add No762
	MM_STATUS	mret = E_MM_STATUS_INVALID;		// 共有オブジェクトステータス//add No762

	{
		index = pUft->through_plane_buf.index_backup_3h;
		in_m_id = pUft->through_plane_buf.mem_item[index].mem_id;
		// 書き込み用出力バッファを取得。
		pItem = vi_app_uf_GetNextBufItem(&pUft->out_plane_buf);

		// 車両下映像の作成。
		if(g_isDispBufValid)
		{
			(void)vi_app_uf_vi_MakeImage(in_m_id, pItem);
		}

		// インデックスの更新のみ。
		(void)vi_app_uf_SetAndGetCurrBufItem(&pUft->out_plane_buf);

		// 作成済みαプレーンを取得。
		if ((g_isDispBufValid) && (pUft->through_plane_buf.first_cycle_cnt > E_VI_UF_BU_FRAME_MAX))
		{
			out_a_m_id = pUft->out_alpha_plane_buf.mem_item[0].mem_id;
			if ((NotLiveBlinkCnt == 0) && (SkeletonNotLiveTimer.t_id == E_TMR_TMRID_INVALID))
			{
				(void)vi_app_Set_OsdOnOff(&vidataP->tbl_add->osd_T.param[vidataP->tbl_add->HD_sys], E_VI_OSD_NOTLIVE_ICON , E_VI_FLG_ON);
				vidataP->tbl_add->line_T.param.Range[2].status = E_VI_PLANE_UPDATE;
				vi_app_SetSkeletonBlinkTimer(&SkeletonNotLiveTimer, E_VI_FLG_OFF);
			}
		}
		else
		{
			out_a_m_id = pUft->out_alpha_plane_buf.mem_item[1].mem_id;
			//(void)vi_app_Set_OsdOnOff(&vidataP->tbl_add->osd_T.param[vidataP->tbl_add->HD_sys], E_VI_OSD_NOTLIVE_ICON , E_VI_FLG_OFF);
			vidataP->tbl_add->line_T.param.Range[2].status = E_VI_PLANE_NOT_UPDATE;
		}
		/* VSP後段の表示バッファの更新 */
		(void)vi_mid_ChangeVspInputBuf(pVsp, VSP_RPF3, 
					pItem->mem_id, E_VI_MALLOC_FAILURE, out_a_m_id);
	}

	return E_VI_SUCCESS;
}

/* dual DL No762 start */
static slong vi_app_uf_BlendProc_2( void )
{
	T_VI_VSP_PARAM_MAIN *pVsp = &m_vi_VspParamMain;
	//T_VI_VSP_PARAM_MAIN *pSub = &m_vi_VspParamSub;// VSPS2
	membmp_id_t in_m_id, out_a_m_id;
	membmp_id_t out_a_s_id;// VSPS2
	S_VI_UF_MEM_ITEM_T *pItem;
	//S_VI_UF_MEM_ITEM_T *pItemSub;// VSPS2
	S_VI_UF_BUF_T *pBuf;// VSPS1
	uint32_t index;
	//sshort i;
#if 1
	//struct_MM_Data_View_Hist_Under_Param	Hist_under;
	MM_STATUS	mret = E_MM_STATUS_INVALID;		// 共有オブジェクトステータス//
#endif


	/* 表示している画面を確認 */
	if( (E_VI_PRM_TOP_FRONT == m_vi_disp_pattern) || (E_VI_PRM_TOP_REAR == m_vi_disp_pattern) )
	{
		return E_VI_SUCCESS;
		/* トップビュー表示時は合成映像から映像を作成 */
		// 最新の合成済みバッファを取得。
		index = ( pVsp->out_buf_index + (VI_VSP_OUT_BUF_MAX - 1) ) % VI_VSP_OUT_BUF_MAX;
		in_m_id = pVsp->out_buf_mem_id[index];
	}
#ifdef USE_3D_OVM	
	else if(E_VI_PRM_3D_OVM_VIEW1 == m_vi_disp_pattern)
	{
		return E_VI_SUCCESS;
		index = (pUft->through_plane_buf.curr_buf_index + pUft->through_plane_buf.buf_num - 2)%(pUft->through_plane_buf.buf_num);
		in_m_id = pUft->through_plane_buf.mem_item[index].mem_id;
	}
#endif		
	else
	{
		/* トップビュー以外の表示時は車両下映像から映像を作成 */
		index = pUft->out_plane_buf.curr_buf_index;
		/* 現在の最新のバッファを取得 */
		in_m_id = vi_app_uf_GetCurrBufId(&pUft->out_plane_buf);
	}


	// 書き込み用出力バッファを取得。
	pItem = vi_app_uf_GetNextBufItem(&pUft->out_plane_buf);
	//pItemSub = vi_app_uf_GetNextBufItem(&pUft->out_plane_bufSub);// VSPS2

	if(E_VI_PRM_3D_OVM_VIEW1 == m_vi_disp_pattern)
	{
		// バックアップデータ設定
		pBuf = &pUft->out_plane_buf;
		pItem = &pBuf->mem_item[index];
		//for( i = 0; i < E_VI_RGB_FRAME_MAX; i++)
		//{
			//pItem = &pBuf->mem_item[i];
		
			//readバッファを描画バッファにコピーする
			CopyReadBuf((uchar *)pItem->virt_addr, s_backupData);
		//}

		// 車両下映像の作成。
		(void)vi_app_uf_vi_MakeImage(in_m_id, pItem);

		// インデックスの更新のみ。
		(void)vi_app_uf_SetAndGetCurrBufItem(&pUft->out_plane_buf);

		// 作成済みαプレーンを取得。
		out_a_m_id = vi_app_uf_GetCurrBufId(&pUft->out_alpha_plane_buf);

		/* VSP後段の表示バッファの更新 */
		(void)vi_mid_ChangeVspInputBuf(pVsp, VSP_RPF3, 
				pItem->mem_id, E_VI_MALLOC_FAILURE, out_a_m_id);

		vi_mid_RecordTimeStamp("UFT", "vsp_out", (slong)index, (slong)pUft->out_plane_buf.curr_buf_index);
	}

#if 0
	// 車両下映像の作成 VSPS2
	(void)vi_app_uf_vi_MakeImage_2(in_m_id, pItemSub);

	// インデックスの更新のみ VSPS2
	(void)vi_app_uf_SetAndGetCurrBufItem(&pUft->out_plane_bufSub);

	// 作成済みαプレーンを取得 VSPS2
	out_a_s_id = vi_app_uf_GetCurrBufId(&pUft->out_alpha_plane_buf);

	/* VSP後段の表示バッファの更新 VSPS2 */
	(void)vi_mid_ChangeVspInputBuf(pSub, VSP_RPF2, 
				pItemSub->mem_id, E_VI_MALLOC_FAILURE, out_a_s_id);

	vi_mid_RecordTimeStamp("UFT_2", "vsp_out", index, pUft->out_plane_bufSub.curr_buf_index);

	vidataP->tbl_add->out_buf_mem_id = m_vi_VspParamSub.out_buf_mem_id[index];

	/* ヒストグラムの取得パラメータ設定 */
	if( vidataP->tbl_add->histarea_write_flg == E_VI_FLG_ON )
	{
		if (E_VI_CAR_HANDLE_LHD == pUft->handle) {
			Hist_under.under.start.X     = HIST_UNDER_START_X_LHD;
			Hist_under.under.start.Y     = HIST_UNDER_START_Y_LHD;
			Hist_under.under.end.X       = HIST_UNDER_END_X_LHD;
			Hist_under.under.end.Y       = HIST_UNDER_END_Y_LHD;
		}
		else {
			Hist_under.under.start.X     = HIST_UNDER_START_X_RHD;
			Hist_under.under.start.Y     = HIST_UNDER_START_Y_RHD;
			Hist_under.under.end.X       = HIST_UNDER_END_X_RHD;
			Hist_under.under.end.Y       = HIST_UNDER_END_Y_RHD;
		}
		Hist_under.under.h_limit_num = E_VI_HIST_BRT_LIMIT_NUM;
		Hist_under.under.l_limit_num = E_VI_HIST_BRT_LIMIT_NUM;
		
		mret = MM_WRITE( E_MM_INFO_TYPE_VIEW, E_MM_DATA_TYPE_VIEW_HIST_UNDER_PARAM, Hist_under );
		if (mret != MM_STATUS_OK)
		{
			// error
			dbg_printfSync("[VIEW_PLANE_UF] vi_app_uf_vi_MakeAlpha MM_WRITE ERROR mret=%x\n", mret);
		}
	}
#endif

	return E_VI_SUCCESS;
}
/* dual DL No762 End */

membmp_id_t vi_app_uf_GetCurrBuf( void )
{
	return vi_app_uf_GetCurrBufId( &pUft->out_plane_buf );
}

#if 0
membmp_id_t vi_app_uf_GetCurrBufSub( void )//add No762
{
	return vi_app_uf_GetCurrBufId( &pUft->out_plane_bufSub );
}
#endif

membmp_id_t vi_app_uf_GetCurrAlphaBuf( void )
{
	return vi_app_uf_GetCurrBufId( &pUft->out_alpha_plane_buf );
}


static slong vi_app_uf_InitImr( int32_t imr_ch, S_VI_IMR_PARAM_TBL *pImr )
{
	T_IMRLSDRV_SOURCE *pSrcSetting;
	int32_t ret_i32;

	// チャネルNo保存。
	pImr->imr_ch = imr_ch;

	/* Start Driver */
	ret_i32 = imrlsdrv_Start( imr_ch );
	if (E_OK != ret_i32)
	{
		ERROR_PRINTF("imrlsdrv_Start fail with %d(CH=%d)\n", ret_i32, imr_ch);
		return E_VI_FAILURE;
	}

	/* Open Driver */
	ret_i32 = imrlsdrv_Open( imr_ch );
	if (E_OK != ret_i32)
	{
		ERROR_PRINTF("imrlsdrv_Open fail with %d(CH=%d)\n", ret_i32, imr_ch);
		return E_VI_FAILURE;
	}

	/* ローカルビデオポート選択 */
	ret_i32 = imrlsdrv_SelVideoSorce( imr_ch, 0 );
	if (ret_i32 != E_OK)
	{
		ERROR_PRINTF("imrlsdrv_SelVideoSorce fail with %d(CH=%d)\r\n", ret_i32, imr_ch);
		return E_VI_FAILURE;
	}

	pSrcSetting = &pImr->imr_src;
	/* ソース設定 */
	pSrcSetting->start_line		= 1;
	pSrcSetting->end_line		= E_VI_CAMERA_LAYOUT_HEIGHT_MAX;
	pSrcSetting->mesh_size		= 3;
	pSrcSetting->source_width	= VI_ALING_32( E_VI_CAMERA_LAYOUT_WIDTH_MAX );
	pSrcSetting->source_height	= E_VI_CAMERA_LAYOUT_HEIGHT_MAX;
	
	ret_i32 = imrlsdrv_SetSource( imr_ch, pSrcSetting );
	if (ret_i32 < E_OK)
	{
		ERROR_PRINTF("imrdrv_SetSoruce fail with %d\r\n", ret_i32);
		return E_VI_FAILURE;
	}

	return E_VI_SUCCESS;
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_set_front_camera_skelton_transmittance
 * 機能        set front camera transmittance for skelton view
 * 引数        uint32_t stride
 * 戻り値      void
 * 作成日      2022/04/08
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        stride
 *
 * 出力        None
 *
 *==============================================================================================
_FCHK_*/
void vi_app_uf_set_front_camera_skelton_transmittance(uint32_t stride)
{
	uint32_t blend_width = (uint32_t)(skelton_view_lt_ori.Y - skelton_view_lt.Y); //Skelton view area and front camera blending width(pixel)
	float_t transmittance = 255.0f; //0.0 ~ 255.0 means transmittance is %100 ~%0
	float_t transmittance_step = transmittance / (float_t)blend_width;
	sshort line = 0;
	uint32_t start_point = 0;
	uint32_t end_point = 0;
	uchar *p_addr = NULL;
	float_t delta = ((float_t)skelton_view_lt.X - (float_t)skelton_view_lb.X) / ((float_t)skelton_view_lb.Y - (float_t)skelton_view_lt.Y);

	if (p_blend_data_01_fr == NULL)
	{
		dbg_printfSync("[VIEW]vi_app_uf_set_front_camera_skelton_transmittance blend_data_01_fr is NULL\n");
	}
	else
	{
		for( line = skelton_view_lt.Y; line <= skelton_view_lb.Y; line++)
		{
	      	if (transmittance >= transmittance_step)
			{
				transmittance = transmittance - transmittance_step;
			}
			else
			{
				transmittance = 0.0f;
			}
			p_addr = p_blend_data_01_fr + (line * stride);  //Calculate the start point(in pixel) of each row on screen
			start_point = ((uint32_t)skelton_view_lt.X - (uint32_t)((float_t)(line - skelton_view_lt.Y) * delta + (float_t)0.5)) + D_UF_SKELTON_BLEND_PIXEL_OFFSET; // + (uint32_t)D_UF_SKELTON_BLEND_WIDTH_SIDE;  //Calculate the start point(in pixel) of skelton view area and rounding
			end_point = ((uint32_t)skelton_view_rt.X + (uint32_t)((float_t)(line - skelton_view_lt.Y) * delta + (float_t)0.5)) - D_UF_SKELTON_BLEND_PIXEL_OFFSET; // - (uint32_t)D_UF_SKELTON_BLEND_WIDTH_SIDE;  //Calculate the end point(in pixel) of skelton view area and rounding
			memset(p_addr + start_point, (uchar)transmittance, end_point - start_point);  //Decreasing transmittance from top to bottom
		}
	}
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_set_side_camera_skelton_transmittance
 * 機能        set left camera and right camera transmittance for skelton view
 * 引数        uint32_t stride
 * 戻り値      void
 * 作成日      2022/04/08
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        stride
 *
 * 出力        None
 *
 *==============================================================================================
_FCHK_*/
void vi_app_uf_set_side_camera_skelton_transmittance(uint32_t stride)
{
	uint32_t blend_width = (uint32_t)(skelton_view_lb_ori.X - skelton_view_lb.X);  //Skelton view area and left/right camera blending width(pixel)
	float_t transmittance = 255.0f;  //0.0 ~ 255.0 means transmittance is %100 ~ %0
	float_t transmittance_step = transmittance / (float_t)blend_width;
	sshort line = 0;
	uint32_t start_point = 0;
	uint32_t end_point = 0;
	uchar *p_addr = NULL;
	uint32_t i = 0;
	float_t delta = ((float_t)skelton_view_lt.X - (float_t)skelton_view_lb.X) / ((float_t)skelton_view_lb.Y - (float_t)skelton_view_lt.Y);

	if (p_blend_data_01_side == NULL)
	{
		dbg_printfSync("[VIEW]vi_app_uf_set_side_camera_skelton_transmittance blend_data_01_side is NULL\n");
	}
	else
	{
		for(line = skelton_view_lt.Y; line <= skelton_view_lb.Y; line++)
		{
			p_addr = p_blend_data_01_side + (line * stride);  //Calculate the start point(in pixel) of each row on screen
			start_point = ((uint32_t)skelton_view_lt.X - (uint32_t)((float_t)(line - skelton_view_lt.Y) * delta + (float_t)0.5)) + D_UF_SKELTON_BLEND_PIXEL_OFFSET;  //Calculate the start point(in pixel) of skelton view area and rounding
			end_point = ((uint32_t)skelton_view_rt.X + (uint32_t)((float_t)(line - skelton_view_lt.Y) * delta + (float_t)0.5)) - D_UF_SKELTON_BLEND_PIXEL_OFFSET;  //Calculate the end point(in pixel) of skelton view area and rounding

			memset(p_addr + start_point, (uchar)0, end_point - start_point);  //Clear a line for skelton view

			transmittance = 255.0f;  //0.0 ~ 255.0 means transmittance is %100 ~ %0
			for (i = 0; i <= blend_width; i++)
			{
				if (transmittance >= transmittance_step)
				{
					transmittance = transmittance - transmittance_step;
				}
				else
				{
					transmittance = 0.0f;
				}

				*(p_addr + start_point + i) = (uchar)transmittance;  //Decreasing transmittance from left side to right side
				*(p_addr + end_point - i) = (uchar)transmittance;  //Increasing transmittance from right side to left side
			}
		}
	}
}

static slong vi_app_uf_LocalInit( void )
{
	S_VI_UF_BUF_T *pBuf;
	membmp_info_t *pInfo;
	slong eret;
	ER ercd;			//Δ1

	// SRC、DST領域の作成
	eret =vi_app_uf_InitMakeArea( vidataP->car_add );
	if( E_VI_SUCCESS != eret )
	{
		// ログ出力のみ。
		ERROR_PRINTF("\n");
	}
	//->Δ3
	//If reading from FlashMemory starts earlier than 1StMuteOff, 1StMuteOff will be delayed by more than 100ms.
	//To avoid this, wait 300ms before starting reading from FlashMemory.
	//In other words, wait 300ms just before vi_app_Read_3DviewMapFlash().
	//msleep(300);						//Aimed after 1ST MUTE OFF
	//<-- Δ3
	//Generate Skeleton Blend
	vi_app_Generate_SkeletonBlend();

	vi_app_set_skeleton_mask();

	//Create front camera and side camera transmittance area for skelton view blending
	vi_app_uf_set_front_camera_skelton_transmittance(E_VI_DISP_LAYOUT_WIDTH_MAX);
	vi_app_uf_set_side_camera_skelton_transmittance(E_VI_DISP_LAYOUT_WIDTH_MAX);

	// イメージ出力用バッファを確保。
	pBuf = &pUft->out_plane_buf;
	pInfo = &pBuf->mem_info;
	pInfo->Width = E_VI_DISP_LAYOUT_WIDTH_MAX;
	pInfo->Height = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	pInfo->bpp = 16U;
	pInfo->Stride = pInfo->Width;
	pInfo->Attr = MEMDRV_YUVSep;
	vi_app_uf_SetupBuf(pBuf, E_VI_RGB_FRAME_MAX);
#if 0
//add No762 start
	pBuf = &pUft->out_plane_bufSub;
	pInfo = &pBuf->mem_info;
	pInfo->Width = E_VI_DISP_LAYOUT_WIDTH_MAX;
	pInfo->Height = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	pInfo->bpp = 16U;
	pInfo->Stride = pInfo->Width;
	pInfo->Attr = MEMDRV_YUVSep;
	vi_app_uf_SetupBuf(pBuf, E_VI_RGB_FRAME_MAX);
//add No762 end
#endif
	// イメージ出力用αバッファを確保。
	pBuf = &pUft->out_alpha_plane_buf;
	pInfo = &pBuf->mem_info;
	pInfo->Width = E_VI_DISP_LAYOUT_WIDTH_MAX;
	pInfo->Height = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	pInfo->bpp = 8U;
	pInfo->Stride = pInfo->Width;
	pInfo->Attr = MEMDRV_8;
	vi_app_uf_SetupBuf(pBuf, E_VI_RGB_FRAME_MAX);
#if 0
	pBuf = &pUft->out_alpha_plane_dummy_buf;
	pInfo = &pBuf->mem_info;
	pInfo->Width = E_VI_DISP_LAYOUT_WIDTH_MAX;
	pInfo->Height = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	pInfo->bpp = 8U;
	pInfo->Stride = pInfo->Width;
	pInfo->Attr = MEMDRV_8;
	vi_app_uf_SetupBuf(pBuf, E_VI_RGB_FRAME_MAX);
#endif
	// through view backup buf
	//pBuf = &pUft->through_plane_buf;
	pInfo = &(pUft->through_plane_buf.mem_info);
	pInfo->Width = E_VI_DISP_LAYOUT_WIDTH_MAX;
	pInfo->Height = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	pInfo->bpp = 16U;
	pInfo->Stride = pInfo->Width;
	pInfo->Attr = MEMDRV_YUVSep;

	vi_app_uf_SetupBUBuf(&pUft->through_plane_buf, E_VI_UF_BU_FRAME_MAX);

	(void)vi_mid_ChangeVspInputBuf(&m_vi_VspParamMain, VSP_RPF3, 
			pUft->out_plane_buf.mem_item[0].mem_id, 
			E_VI_MALLOC_FAILURE, 
			pUft->out_alpha_plane_buf.mem_item[0].mem_id);
	
	// IMRLSXの初期化。
	eret = vi_app_uf_InitImr( D_VI_IMRLSX_UF_CH, &pUft->imr_param );
	if( E_VI_SUCCESS != eret )
	{
		// ログ出力のみ。
		ERROR_PRINTF("\n");
	}

	// デドレコ保存領域の初期化
	(void)vi_app_uf_deadrecinfo(&s_drec_info);

	// mapdata for through view backup
	pUft->dl_id_bu = vi_app_uf_loadMapFlash_BU();

	(void)vi_app_uf_vi_MakeAlpha();

	SkeletonNotLiveTimer.cmd = E_VI_SKELETON_600MS;
	SkeletonNotLiveTimer.value = SKELETON_VIEW_BLINK_TIME;
	SkeletonNotLiveTimer.t_id = E_TMR_TMRID_INVALID;

	return E_VI_SUCCESS;
}


static slong vi_app_uf_SetupBuf(S_VI_UF_BUF_T *pBuf, uint32_t buf_num)
{
	uint32_t i;
	Error ercd;
	membmp_info_t *pInfo;
	S_VI_UF_MEM_ITEM_T *pMem;

	// パラメータチェック
	if( NULL == pBuf )
	{
		ERROR_PRINTF("\n");
		return E_VI_FAILURE;
	}

	if( (E_VI_RGB_FRAME_MAX < buf_num) || (0U == buf_num) )
	{
		ERROR_PRINTF("Param error buf_num=%d\n", buf_num);
		return E_VI_FAILURE;
	}
	
	pBuf->buf_num = buf_num;
	pInfo = &pBuf->mem_info;
	pMem = &pBuf->mem_item[0];

	for( i = 0U; i < pBuf->buf_num; i ++ )
	{
		pMem->mem_id = vi_allocImageMemoryNoInit( pInfo->Width, pInfo->Height, pInfo->bpp, pInfo->Attr );
		if( E_VI_MALLOC_FAILURE < pMem->mem_id )
		{
			ercd = memdrv_MemBitmapPhysAddrGet( pMem->mem_id, &pMem->phy_addr );
			if (Success != ercd)
			{
				ERROR_PRINTF("\n");
				pMem->phy_addr = 0U;
			}
			ercd = memdrv_MemBitmapVirtAddrGet( pMem->mem_id, &pMem->virt_addr );
			if (Success != ercd)
			{
				ERROR_PRINTF("\n");
				pMem->virt_addr = NULL;
			}
		}
		else
		{
			ERROR_PRINTF("\n");
			return E_VI_FAILURE;
		}

		pMem ++;
	}
	
	if( MEMDRV_YUVSep == pInfo->Attr)
	{
		pBuf->uv_offset = pInfo->Stride * pInfo->Height;
	}
	else
	{
		// 未使用
		pBuf->uv_offset = 0U;
	}

	// バッファインデックスを初期化。
	pBuf->curr_buf_index = 0U;
	pBuf->next_buf_index = 0U;

	return E_VI_SUCCESS;
}


static slong vi_app_uf_vi_MakeImage(membmp_id_t in_mem_id, S_VI_UF_MEM_ITEM_T *pItem)
{
	int32_t ret_i32;
	S_VI_IMR_PARAM_TBL *pImr = &pUft->imr_param;
	UW					*dl_phy_addr;
	int32_t 			imrls_ch = pImr->imr_ch;
	T_IMRLSDRV_2DPOS	dst_pos = {0, 0};
	uint32_t			mode = IMRLS_REG_TRIMR_TME | IMRLS_REG_TRIMR_BFE;
	//add No762
	//dbg_printfSync("[vi_app_uf_vi_MakeImage]@@@ dl_id = x%x, stats(%d)\n", pUft->dl_id, UfBackup_IGN_Flag);//debug Test
	//dl_phy_addr = imrlib_getDLPhysicalAddr( pUft->dl_id );
	dl_phy_addr = imrlib_getDLPhysicalAddr( pUft->dl_id_sub);
	
	if( NULL == dl_phy_addr )
	{
		ERROR_PRINTF("\n");
		return E_VI_FAILURE;
	}

	ret_i32 = imrlsdrv_ExecuteExtDlAddr(
					imrls_ch,						// IMRチャンネルNo
					(void *)dl_phy_addr,			// ディスプレイリスト
					in_mem_id,						// 入力画像のBitmapID
					pItem->mem_id,					// 出力画像のBitmapID
					&dst_pos,
					mode,
					IMRLSDRV_EXEC_Y,
					0,
					0 );
	if( E_OK != ret_i32 )
	{
		//add No762
		ERROR_PRINTF("imrlsdrv_Execute(Top_Under Y) error %d\n", ret_i32);
		return E_VI_FAILURE;
	}

	/* 変換の終了を待つ */
	ret_i32 = imrlsdrv_WaitEvent( imrls_ch );
	if( 0x01 != ( ret_i32 & 0x01 ) )		// レンダリング完了をチェック
	{
		//add No762
		ERROR_PRINTF("imrlsdrv_WaitEvent(Top_Under Y) error %x\n", ret_i32);
		return E_VI_FAILURE;
	}

	vi_mid_RecordTimeStamp("IMRLSX", "y_out", (slong)pItem->mem_id, (slong)in_mem_id);


	/* UV映像の俯瞰変換 */
	ret_i32 = imrlsdrv_ExecuteExtDlAddr(
					imrls_ch,						// IMRチャンネルNo
					(void *)dl_phy_addr,			// ディスプレイリスト
					in_mem_id,						// 入力画像のBitmapID
					pItem->mem_id,					// 出力画像のBitmapID
					&dst_pos,
					mode,
					IMRLSDRV_EXEC_UV,
					0,
					0 );
	if( E_OK != ret_i32 )
	{
		//add No762
		ERROR_PRINTF("imrlsdrv_Execute(Top_Under UV) error %d\n", ret_i32);
		return E_VI_FAILURE;
	}

	/* 変換の終了を待つ */
	ret_i32 = imrlsdrv_WaitEvent( imrls_ch );
	if( 0x01 != ( ret_i32 & 0x01 ) )		// レンダリング完了をチェック
	{
		//add No762
		ERROR_PRINTF("imrlsdrv_WaitEvent(Top_Under UV) error %x\n", ret_i32);
		return E_VI_FAILURE;
	}

	vi_mid_RecordTimeStamp("IMRLSX", "uv_out", (slong)pItem->mem_id, (slong)in_mem_id);

	return E_VI_SUCCESS;
}

/* dual DL No762 start */
static slong vi_app_uf_vi_MakeImage_2(membmp_id_t in_mem_id, S_VI_UF_MEM_ITEM_T *pItem)
{
	int32_t ret_i32;
	S_VI_IMR_PARAM_TBL *pImr = &pUft->imr_param;
	UW					*dl_phy_addr_sub;
	int32_t 			imrls_ch_sub = pImr->imr_ch;
	T_IMRLSDRV_2DPOS	dst_pos = {0, 0};
	uint32_t			mode = IMRLS_REG_TRIMR_TME | IMRLS_REG_TRIMR_BFE;

	//dbg_printfSync("[vi_app_uf_vi_MakeImage_2]@@@ dl_id_sub =x%x, stats(%d)\n", pUft->dl_id_sub, UfBackup_IGN_Flag);//debug Test
	dl_phy_addr_sub = imrlib_getDLPhysicalAddr( pUft->dl_id_sub );
	ret_i32 = imrlsdrv_ExecuteExtDlAddr(
					imrls_ch_sub,
					(void *)dl_phy_addr_sub,
					in_mem_id,
					pItem->mem_id,
					&dst_pos,
					mode,
					IMRLSDRV_EXEC_Y,
					0,
					0 );
	if( E_OK != ret_i32 )
	{
		ERROR_PRINTF("imrlsdrv_Execute(Top_Under Y sub) error %d\n", ret_i32);
		return E_VI_FAILURE;
	}
	ret_i32 = imrlsdrv_WaitEvent( imrls_ch_sub );
	if( 0x01 != ( ret_i32 & 0x01 ) )
	{
		ERROR_PRINTF("imrlsdrv_WaitEvent(Top_Under Y sub) error %x\n", ret_i32);
		return E_VI_FAILURE;
	}
	ret_i32 = imrlsdrv_ExecuteExtDlAddr(
					imrls_ch_sub,
					(void *)dl_phy_addr_sub,
					in_mem_id,
					pItem->mem_id,
					&dst_pos,
					mode,
					IMRLSDRV_EXEC_UV,
					0,
					0 );
	if( E_OK != ret_i32 )
	{
		ERROR_PRINTF("imrlsdrv_Execute(Top_Under UV sub) error %d\n", ret_i32);
		return E_VI_FAILURE;
	}
	ret_i32 = imrlsdrv_WaitEvent( imrls_ch_sub );
	if( 0x01 != ( ret_i32 & 0x01 ) )
	{
		ERROR_PRINTF("imrlsdrv_WaitEvent(Top_Under UV sub) error %x\n", ret_i32);
		return E_VI_FAILURE;
	}

	return E_VI_SUCCESS;
}

static slong vi_app_uf_UpdateDl( void )
{
	slong rcode;	

	//デドレコ情報の取得
	(void)vi_app_uf_deadrecinfo(&s_drec_info);

	// αプレーン更新。
	//(void)vi_app_uf_vi_MakeAlpha();
		
	// Src領域作成
	{
		// Src領域作成
		rcode = vi_app_uf_MakeSrcCoord_3h();
		if (E_VI_SUCCESS != rcode)
		{
			//dbg_printfSync("[View]vi_app_uf_MakeSrcCoord_3h Error\n");
			g_isDispBufValid = FALSE;
			return E_VI_FAILURE;
		}
		else
		{
			g_isDispBufValid = TRUE;
		}
		// DL作成
		(void)vi_app_uf_GetLayout_3h();
	}

	return E_VI_SUCCESS;
}


// αの穴あけ
static slong vi_app_uf_vi_MakeAlpha( void )
{
	S_VI_TBL_DATA *pTbl = (S_VI_TBL_DATA *)vidataP->tbl_add;
	T_IMRLIB_RECT rc_clip = { 0 };
	S_VI_UF_MEM_ITEM_T *pItem;
	uint32_t mem_size;
	Error memRet;
	uchar *p_addr;
	uint32_t y;

	mem_size = pUft->out_alpha_plane_buf.mem_info.Stride * pUft->out_alpha_plane_buf.mem_info.Height;

	//pItem = vi_app_uf_GetNextBufItem(&pUft->out_alpha_plane_buf);
	pItem = &(pUft->out_alpha_plane_buf.mem_item[0]);
	//mem_size = pUft->out_alpha_plane_buf.mem_info.Stride * pUft->out_alpha_plane_buf.mem_info.Height;
	memset(pItem->virt_addr, 0x00, mem_size);
	{
		/* クリップ領域の作成*/
		rc_clip.lt.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X;	// max area X
		rc_clip.lt.Y = (H)DstScreenCoord_3h[0].Y;										
		rc_clip.rb.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X;
		rc_clip.rb.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y;

		for( y = rc_clip.lt.Y; y < rc_clip.rb.Y; y ++ )
		{
			p_addr = (uchar *)pItem->virt_addr + (y * pUft->out_alpha_plane_buf.mem_info.Stride);

			p_addr += rc_clip.lt.X;
			memset( p_addr, 0xFF, (size_t)(rc_clip.rb.X - rc_clip.lt.X));
		}
	}

	memRet = memdrv_MemBitmapPurge(pItem->mem_id, (uint32_t)pItem->virt_addr, (uint32_t)pItem->virt_addr + mem_size);
	if( Success != memRet )
	{
		ERROR_PRINTF("memdrv_MemBitmapPurge fail:memRet=%d \n",memRet);
		return E_VI_FAILURE;
	}

	/* Make a dummy alpha plane for invalid display */
	//pItem = vi_app_uf_GetNextBufItem(&pUft->out_alpha_plane_dummy_buf);
	//pItem = &(pUft->out_alpha_plane_dummy_buf.mem_item[0]);
	//mem_size = pUft->out_alpha_plane_dummy_buf.mem_info.Stride * pUft->out_alpha_plane_dummy_buf.mem_info.Height;
	pItem = &(pUft->out_alpha_plane_buf.mem_item[1]);
	//mem_size = pUft->out_alpha_plane_buf.mem_info.Stride * pUft->out_alpha_plane_buf.mem_info.Height;
	memset(pItem->virt_addr, 0x00, mem_size);
	{
		rc_clip.lt.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X;	// max area X
		rc_clip.lt.Y = (H)DstScreenCoord_3h[0].Y;
		rc_clip.rb.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X;
		rc_clip.rb.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y;

		for( y = rc_clip.lt.Y; y < rc_clip.rb.Y; y ++ )
		{
			//p_addr = (uchar *)pItem->virt_addr + (y * pUft->out_alpha_plane_dummy_buf.mem_info.Stride);
			p_addr = (uchar *)pItem->virt_addr + (y * pUft->out_alpha_plane_buf.mem_info.Stride);

			p_addr += rc_clip.lt.X;
			memset( p_addr, 0x00, (rc_clip.rb.X - rc_clip.lt.X) );
		}
	}

	memRet = memdrv_MemBitmapPurge(pItem->mem_id, (uint32_t)pItem->virt_addr, (uint32_t)pItem->virt_addr + mem_size);
	if( Success != memRet )
	{
		ERROR_PRINTF("memdrv_MemBitmapPurge fail:memRet=%d \n",memRet);
		return E_VI_FAILURE;
	}

	// インデックスの更新のみ。
	//(void)vi_app_uf_SetAndGetCurrBufItem(&pUft->out_alpha_plane_buf);

	return E_VI_SUCCESS;

}


/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_GetLayout
* 機能         SRC領域とDST領域でDLを作成
 * 引数        なし
 * 戻り値      slong
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_GetLayout( void )
{
	T_IMRLIB_RECT	rc_clip;
	T_IMRLIB_2DPOS	pt_src[D_VI_UF_RECT_MAX], pt_dst[D_VI_UF_RECT_MAX];
	T_IMRLIB_2DPOS	pitch;//add No762
	T_IMRLIB_2DPOS	num;
	ER_ID dl_id;
	ER_ID dl_id_sub;//dual DL No762
	int i;
	S_VI_F_COORDINATE srcTmp[D_VI_UF_RECT_MAX];
	S_VI_TBL_DATA *pTbl = (S_VI_TBL_DATA *)vidataP->tbl_add;
#if 1
	slong eret = E_VI_SUCCESS;
#endif
	
	// ハンドル情報取得。
	pUft->handle = pTbl->HD_sys;
	
	/* No762DEBUG */
	/* SRCの幅、高さをDSTに合わせる */
	vi_app_uf_makeDSTRectBySRC(DstScreenCoord, SrcScreenCoord, srcTmp);
	/* DSTの幅高さを求める */
	//No762 形／色輝度等の平滑化
	pitch.X = (sshort)(vi_app_uf_GetDistance(&DstScreenCoord[D_VI_UF_RECT_LB], &DstScreenCoord[D_VI_UF_RECT_RB]));
	pitch.Y = (sshort)(vi_app_uf_GetDistance(&DstScreenCoord[D_VI_UF_RECT_LB], &DstScreenCoord[D_VI_UF_RECT_LT]));
	
	//SRCを四捨五入する
	if(debug_45flag == 1)
	{
		for(i=0; i < D_VI_UF_RECT_MAX; i++)
		{
			srcTmp[i].X = CMN_F32ABSROUND(srcTmp[i].X);
			srcTmp[i].Y = CMN_F32ABSROUND(srcTmp[i].Y);
		}
	}	

	memcpy(SrcScreenCoord, srcTmp, sizeof(SrcScreenCoord));

#if 0
	if(uf_debug_xyflag != 0)
	{
		/* DSTとデバッグ値からSRCを作成 */
		vi_app_uf_DebugSRC(DstScreenCoord, SrcScreenCoord, srcTmp);
		memcpy(SrcScreenCoord, srcTmp, sizeof(SrcScreenCoord));
	}
#endif
	
	/* No762DEBUG */
	memcpy(SrcScreenCoord_DEBUG, SrcScreenCoord, sizeof(SrcScreenCoord));
	memcpy(DstScreenCoord_DEBUG, DstScreenCoord, sizeof(DstScreenCoord));

	/* No762DEBUG */
	//shortに変換したあとのdmup用
	for( i = 0; i < D_VI_UF_RECT_MAX; i++ )
	{
		
		pt_dst_DEBUG[i].X = (H)(DstScreenCoord[i].X);
		pt_dst_DEBUG[i].Y = (H)(DstScreenCoord[i].Y);
	}
	/* SRC領域の変換 */
	for( i = 0; i < D_VI_UF_RECT_MAX; i++ )
	{
		pt_src_DEBUG[i].X = (H)(SrcScreenCoord[i].X);
		pt_src_DEBUG[i].Y = (H)(SrcScreenCoord[i].Y);
	}
	
	/* No762DEBUG */
	//shortに変換したあとのdmup用
	for( i = 0; i < D_VI_UF_RECT_MAX; i++ )
	{
		
		pt_dst_DEBUG[i].X = (H)(DstScreenCoord[i].X);
		pt_dst_DEBUG[i].Y = (H)(DstScreenCoord[i].Y);
	}
	/* SRC領域の変換 */
	for( i = 0; i < D_VI_UF_RECT_MAX; i++ )
	{
		pt_src_DEBUG[i].X = (H)(SrcScreenCoord[i].X);
		pt_src_DEBUG[i].Y = (H)(SrcScreenCoord[i].Y);
	}
	
	/* DST領域の変換 */
	for( i = 0; i < D_VI_UF_RECT_MAX; i++ )
	{
		//add No762
		pt_dst[i].X = (H)(DstScreenCoord[i].X);
		pt_dst[i].Y = (H)(DstScreenCoord[i].Y);
	}

	/* SRC領域の変換 */
	for( i = 0; i < D_VI_UF_RECT_MAX; i++ )
	{
		//add No762
		pt_src[i].X = (H)((SrcScreenCoord[i].X) * 4);
		pt_src[i].Y = (H)((SrcScreenCoord[i].Y) * 4);
	}

	/* クリップ領域の作成*/
	rc_clip.lt.X = (H)DstScreenCoord[D_VI_UF_RECT_LT].X;
	rc_clip.lt.Y = (H)DstScreenCoord[D_VI_UF_RECT_LT].Y;
	rc_clip.rb.X = (H)DstScreenCoord[D_VI_UF_RECT_RB].X;
	rc_clip.rb.Y = (H)DstScreenCoord[D_VI_UF_RECT_RB].Y;

	/* 頂点数 */
	num.X = 2;
	num.Y = 2;

	/* DL作成 */
	//add No762
	dl_id = imrlib_makeDLAutoMeshDst_Brightness(pt_src, pitch, num, pt_dst[0], &rc_clip );
	if( E_VI_MALLOC_FAILURE == dl_id )
	{
		// DL作成失敗。
		ERROR_PRINTF("\n");
		return E_VI_FAILURE;
	}
	else
	{
		//add No762
		if( E_VI_MALLOC_FAILURE != pUft->dl_id )
		{
			// 作成済みDLを破棄。
			imrlib_deleteDL( pUft->dl_id );
			pUft->dl_id = E_VI_MALLOC_FAILURE;
		}
		// 作成したDLを保存。
		pUft->dl_id = dl_id;
		//pUft->oddYUVaddr = imrlib_getDLYuvCPRAddr(pUft->dl_id);
		/* dual DL No762 */
		dl_id_sub = imrlib_makeDLAutoMeshDst_Brightness(pt_src, pitch, num, pt_dst[0], &rc_clip );
		if( E_VI_MALLOC_FAILURE == dl_id_sub )
		{
			// DL作成失敗。
			ERROR_PRINTF("\n");
			return E_VI_FAILURE;
		}
		else
		{
			if( E_VI_MALLOC_FAILURE != pUft->dl_id_sub )
			{
				imrlib_deleteDL( pUft->dl_id_sub );
				pUft->dl_id_sub = E_VI_MALLOC_FAILURE;
			}
		}
		pUft->dl_id_sub = dl_id_sub;
		pUft->oddYUVaddr = imrlib_getDLYuvCPRAddr(pUft->dl_id_sub);
		/* dual DL No762 */
		//dbg_printfSync("[vi_app_uf_GetLayout]@@@ dl_id = x%x, dl_id_sub = x%x, stats(%d)\n", pUft->dl_id, pUft->dl_id_sub, UfBackup_IGN_Flag);//debug Test
#if 0
		// 輝度補正
		eret = vi_app_uf_bc_regset();
		if( E_VI_SUCCESS != eret )
		{
			// ログ出力のみ。
			ERROR_PRINTF("\n");
		}
#endif
	}
	return E_VI_SUCCESS;
}

#if 0
//add No762
// 輝度補正データ設定処理
slong vi_app_uf_bc_regset( void )
{
	MM_STATUS rc = E_MM_STATUS_INVALID;
	S_VI_CAMERA_BC_DL_DATA pDL_data;
	static struct_MM_Data_Under_Brightness_Value		uf_data;
	schar Y_set;
	uchar Cont_set;
	schar Cb_set;
	schar Cr_set;
	ulong scale;
	ulong offset;
	uint32_t wkaddr;
	
	if( pUft->oddYUVaddr == NULL )
	{
		return E_VI_FAILURE;
	}
	
	rc = MM_READ(E_MM_INFO_TYPE_VIEW, E_MM_DATA_TYPE_UNDER_BRIGHTNESS_VALUE, uf_data);
	if (E_MM_STATUS_OK != rc) {
		return E_VI_FAILURE;
	}
#if 1
	if ( 1 == m_vi_bright_mode )
	{
		// test dark
		uf_data.brt = -49.2697;
		uf_data.cont = 1;
		uf_data.cb_col = 1.67688;
		uf_data.cr_col = -0.733409;
	}
	else if (2 == m_vi_bright_mode )
	{
		// test bright
		uf_data.brt = 51.9787;
		uf_data.cont = 1;
		uf_data.cb_col = -1.63966;
		uf_data.cr_col = 4.29007;
	}
#endif
	//dbg_printfSync("[vi_app_uf_bc_regset]@@@ brt = %f, cont = %f, cb_col = %f, cr_col = %f\n", uf_data.brt ,uf_data.cont ,uf_data.cb_col ,uf_data.cr_col );//debug Test
	Y_set = (schar)(uf_data.brt + E_VI_ROUNDED_NUM);
	Cont_set = (uchar)((uf_data.cont * 128.0F) + E_VI_ROUNDED_NUM);
	Cb_set = (schar)(uf_data.cb_col + E_VI_ROUNDED_NUM);
	Cr_set = (schar)(uf_data.cr_col + E_VI_ROUNDED_NUM);
	pDL_data.luv[0] = ((Cont_set & 0xFFU) << 16) | ((uchar)Y_set & 0xFFU);
	pDL_data.luv[1] = (0x00000001U << 16) | ((uchar)Cb_set & 0xFFU);
	pDL_data.luv[2] = (0x00000001U << 16) | ((uchar)Cr_set & 0xFFU);
	
	// 輝度補正レジスタ設定
	scale = (ushort)((pDL_data.luv[0] & 0x00FF0000U) >> 8);
	offset = (ushort)(pDL_data.luv[0] & 0x000000FFU);
	*(ulong *)pUft->oddYUVaddr = (0x00000082U << 24) | ((IMRLS_REG_OFFSET_YLCPR >> 2) << 16) | (scale | offset);
	//dbg_printfSync("[vi_app_uf_bc_regset]@[0][0x%x]\n", *(ulong *)pUft->oddYUVaddr );//debug Test
	pUft->oddYUVaddr++;
	
	scale = (ushort)((pDL_data.luv[1] & 0x00FF0000U) >> 8);
	offset = (ushort)(pDL_data.luv[1] & 0x000000FFU);
	*(ulong *)pUft->oddYUVaddr = (0x00000082U << 24) | ((IMRLS_REG_OFFSET_UBCPR >> 2) << 16) | (scale | offset);
	//dbg_printfSync("[vi_app_uf_bc_regset]@[1][0x%x]\n", *(ulong *)pUft->oddYUVaddr );//debug Test
	pUft->oddYUVaddr++;
	
	scale = (ushort)((pDL_data.luv[2] & 0x00FF0000U) >> 8);
	offset = (ushort)(pDL_data.luv[2] & 0x000000FFU);
	*(ulong *)pUft->oddYUVaddr = (0x00000082U << 24) | ((IMRLS_REG_OFFSET_VRCPR >> 2) << 16) | (scale | offset);
	//dbg_printfSync("[vi_app_uf_bc_regset]@[2][0x%x]\n", *(ulong *)pUft->oddYUVaddr );//debug Test
	
	wkaddr = (uint32_t)imrlib_getDLVirtualAddr(pUft->dl_id_sub);
	//メモリキャッシュを強制的に反映
	memdrv_MemBitmapPurge(pUft->dl_id_sub, wkaddr, wkaddr + (uint32_t)imrlib_getDLSize(pUft->dl_id_sub));
	return E_VI_SUCCESS;
}
#endif

static slong vi_app_uf_GetLayout_VEHICLE(T_IMRLIB_RECT *rect, const S_VI_LAYOUT_DATA *layout, uchar handle)
{
	S_VI_COORDINATE cood;

	//(void)vi_mid_get_layout_t8( &cood, layout, handle );
	(void)vi_mid_get_layout(&cood, layout, handle, 8, LAYOUT_T);
	
	rect->lt.X = cood.X;
	rect->lt.Y = cood.Y;

	//(void)vi_drv_get_layout_t13( &cood, layout, handle );
	(void)vi_mid_get_layout(&cood, layout, handle, 13, LAYOUT_T);
	
	rect->rb.X = cood.X;
	rect->rb.Y = cood.Y;

	return E_VI_SUCCESS;

}


/*_FCHK_
 *==============================================================================================
 *	関数名		vi_app_IPA_UpdatePos
 *	機能		IPAデッドレコニングの更新により、駐車枠座標を自車を原点とする座標に変換
 *	引数		なし
 *	戻り値		なし
 *	備考		※AVM_IPAでの元関数：hm_gr_UpdatePos_ipa()
 *	備考		※R_Carでの元関数：vi_app_IPA_UpdatePos()
 *	作成日		2012.06.01
 *	最終更新日	2015.04.06 共有オブジェ参照先を変更
 *	逸脱手続日  
 *	
 *----------------------------------------------------------------------------------------------
 *	実施日付		判定		担当
 *----------------------------------------------------------------------------------------------
 *	2012.10.11		○			arayay
 *----------------------------------------------------------------------------------------------
 *	確認項目		確認内容
 *----------------------------------------------------------------------------------------------
 *	分岐確認		ケース分岐のみ
 *	無限ループ		なし
 *	変数初期化		グローバル変数初期化OK、内部変数は使用前にデータ登録あり
 *	変数領域外		領域外への書き込み処理なし
 *	入力			なし
 *	出力			なし
 *	検出修正数		0
 *---------------------------------------------------------------------------------------------
 *	テスト数		1			UT 不具合数			0			ICE 不具合数			0
 *==============================================================================================
_FCHK_*/
static void vi_app_uf_MakeSrcCoord( void )
{
	//struct_MM_Data_Deadrecog			mm_reckon_ave_pre;		/* 前回の平均値 */
	//struct_MM_Data_Deadrecog			mm_reckon_ave;			/* 今回の平均値 */
	//struct_MM_Data_Deadrecog			mm_reckon;				/* 今回取得値 */
	//MM_STATUS							mm_sts = E_MM_STATUS_INVALID;
	S_VI_UF_POS							pos;				/* 今回の移動量計算用 */
	int								i;
	double_t							rad = 0.0;
	//S_VI_F_COORDINATE					tmp_pre[D_VI_UF_RECT_MAX];	/* (前回世界座標)座標作成一時領域用 */
	S_VI_F_COORDINATE					tmp[D_VI_UF_RECT_MAX];		/* (今回世界座標)座標作成一時領域用 */
	//double_t							lng = 0.0;
	

#if 1
	/* 後輪車軸中心(0,0）原点の座標から、矩形の世界座標→相対座標を計算する */
	(void)vi_app_uf_CalcMyRect( RcgLocalCoord, &s_drec_info.deadrec_info[s_drec_info.rw_point], &s_drec_info_pre, tmp);
#endif

#if 1
	/*************Wheelbase分後退（オフセット）させ、領域を90°回転***************/
	pos.pos_x = vidataP->car_add->car_data.Wheelbase;
	pos.pos_y = 0.0;
	rad = VI_GR_DEG2RAD( -90 );
	pos.sin_yaw = sin( rad );
	pos.cos_yaw = cos( rad );
	/*************暫定で１m前進***************/
	/* クリップする自車下領域を計算 */
	for( i = D_VI_UF_RECT_LT; i < D_VI_UF_RECT_MAX; i ++ )
	{
		/* 差分から、クリップするSrc座標の領域を計算 */
		vi_app_uf_calcPos( &tmp[i], &SrcLocalCoord[i], &pos );
	}
#endif
	/* Src座標を画面座標に変換 */
	(void)vi_app_uf_convert_ScreenCoord( SrcLocalCoord, SrcScreenCoord, vidataP->car_add );

	// 前回デドレコ情報を更新
	s_drec_info_pre.vp_rear_wpos_x = s_drec_info.deadrec_info[s_drec_info.rw_point].vp_rear_wpos_x;
	s_drec_info_pre.vp_rear_wpos_y = s_drec_info.deadrec_info[s_drec_info.rw_point].vp_rear_wpos_y;
	s_drec_info_pre.vp_rear_angle = s_drec_info.deadrec_info[s_drec_info.rw_point].vp_rear_angle;

}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_RecSkeltonViewCoord
 * 機能        Record all skelton view associated edge point coordinates(before & after expand)
 * 引数        void
 * 戻り値      void
 * 作成日      2022/05/23
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        None
 *
 * 出力        None
 *
 *==============================================================================================
_FCHK_*/
void  vi_app_uf_RecSkeltonViewCoord(void)
{
	//Record single skelton view associated edge point coordinates(before & after expand)
	skelton_view_lt.X = (H)DstScreenCoord_3h[0].X;
	skelton_view_lt.Y = (H)DstScreenCoord_3h[0].Y;
	skelton_view_lb.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM - D_UF_3H_DST_X_PITCH].X;
	skelton_view_lb.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM - D_UF_3H_DST_X_PITCH].Y;
	skelton_view_rt.X = (H)DstScreenCoord_3h[D_UF_3H_DST_X_PITCH - 1].X;
	skelton_view_rt.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_X_PITCH - 1].Y;
	skelton_view_rb.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X;
	skelton_view_rb.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y;
	skelton_view_lt_ori.X = (H)DstScreenCoord_3h_ori[0].X;
	skelton_view_lt_ori.Y = (H)DstScreenCoord_3h_ori[0].Y;
	skelton_view_lb_ori.X = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM - D_UF_3H_DST_X_PITCH].X;
	skelton_view_lb_ori.Y = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM - D_UF_3H_DST_X_PITCH].Y;
	skelton_view_rt_ori.X = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_X_PITCH - 1].X;
	skelton_view_rt_ori.Y = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_X_PITCH - 1].Y;
	skelton_view_rb_ori.X = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM-1].X;
	skelton_view_rb_ori.Y = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM-1].Y;

}


/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_adapt_InitArea
 * 機能       Adjust InitArea to be displayable
 * 引数        void
 * 戻り値      void
 * 作成日      2022/10/11
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        None
 *
 * 出力        None
 *
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_adapt_InitArea(S_VI_F_COORDINATE *point, 	slong x_max, slong y_max)
{
	uint32 i, j, k;
	float_t temp_x, temp_y;
	if (point == NULL) { 
		return E_VI_FAILURE;
	}
	for (i = 0U; i < D_UF_3H_DST_Y_PITCH; i++)
	{
		for (j = 0U; j < D_UF_3H_DST_X_PITCH; j++)
		{
			k = i * D_UF_3H_DST_X_PITCH + j;
			if (point[k].Y > (float_t)y_max) {
				if (i == 0U){
					return E_VI_FAILURE;//Car out of display range
				}
				temp_x = point[(i - 1U) * D_UF_3H_DST_X_PITCH + j].X;
				temp_y = point[(i - 1U) * D_UF_3H_DST_X_PITCH + j].Y;
				point[k].X = ((point[k].X - temp_x) / (point[k].Y - temp_y)) * ((float_t)y_max - temp_y) + temp_x;
				point[k].Y = (float_t)y_max;
			}
			if (point[k].X > (float_t)x_max) {
				point[k].X = (float_t)x_max;
			}
		}
	}
	return E_VI_SUCCESS;
}

/*_FCHK_
 *==============================================================================================
 *  function name       vi_app_nosig_mask_set_quadrilateral
 * 
 *  function           	Set the four vertex coordinates of the quadrilateral drawn when the video is interrupted
 *						
 *	parameter			uchar index							Arrangement position of the area for display management of video interruption rectangle display
 *						const S_VI_COORDINATE *p_fl_pos		the pointer of the front left point coordinate
 *						const S_VI_COORDINATE *p_fr_pos		the pointer of the front right point coordinate
 *						const S_VI_COORDINATE *p_rr_pos		the pointer of the rear right point coordinate
 *						const S_VI_COORDINATE *p_rl_pos		the pointer of the rear left point coordinate
 *						
 *	return				slong E_VI_SUCCESS
 *						slong E_VI_FAILURE
 *
 *  *===========================================================================================
_FCHK_*/
static slong vi_app_nosig_mask_set_quadrilateral( uchar index, const S_VI_COORDINATE *p_fl_pos,const S_VI_COORDINATE *p_fr_pos, const S_VI_COORDINATE *p_rr_pos, const S_VI_COORDINATE *p_rl_pos)
{
	if ((NULL == p_fl_pos) || (NULL == p_fr_pos) || (NULL == p_rr_pos) || (NULL == p_rl_pos))
	{
		return E_VI_FAILURE;
	}

	if(E_VI_RECT_NOSIGNAL_MASK_MAX <= index)
	{
		return E_VI_FAILURE;
	}

	/* Sets quad information by combining the coordinates of four vertices */
	m_vi_rect_nosignal_mask_data.rect[index][0].X = p_fl_pos->X;
	m_vi_rect_nosignal_mask_data.rect[index][0].Y = p_fl_pos->Y;
	m_vi_rect_nosignal_mask_data.rect[index][1].X = p_fr_pos->X;
	m_vi_rect_nosignal_mask_data.rect[index][1].Y = p_fr_pos->Y;
	m_vi_rect_nosignal_mask_data.rect[index][2].X = p_rr_pos->X;
	m_vi_rect_nosignal_mask_data.rect[index][2].Y = p_rr_pos->Y;
	m_vi_rect_nosignal_mask_data.rect[index][3].X = p_rl_pos->X;
	m_vi_rect_nosignal_mask_data.rect[index][3].Y = p_rl_pos->Y;
}

/*_FCHK_
 *==============================================================================================
 *  function name       vi_app_set_skeleton_mask
 * 
 *  function           	Set the masks for the front, left and right cameras when the video is interrupted
 *
 *  *===========================================================================================
_FCHK_*/
void vi_app_set_skeleton_mask()
{	
	S_VI_COORDINATE							fl_pos;			/* the pointer of the top left point coordinate */
	S_VI_COORDINATE							rr_pos;			/* the pointer of the bottom right point coordinate */
	S_VI_COORDINATE							fr_pos;			/* the pointer of the top right point coordinate */ 
	S_VI_COORDINATE							rl_pos;			/* the pointer of the bottom left point coordinate */
	
	/* use for skeleton mask drawing */
	S_VI_COORDINATE							dst_tl;			
	S_VI_COORDINATE							dst_tr;			
	S_VI_COORDINATE							dst_bl;
	S_VI_COORDINATE							dst_br;		
 
	S_VI_COORDINATE							dst_tl_b;			
	S_VI_COORDINATE							dst_tr_b;			
	S_VI_COORDINATE							dst_bl_b;
	S_VI_COORDINATE							dst_br_b;		
	
	

	/* the coordinate of Hood view top left point */
	dst_tl.X = (H)DstScreenCoord_3h_ori[0].X;
	dst_tl.Y = (H)DstScreenCoord_3h_ori[0].Y;
	
	/* the coordinate of Hood view top right point */
	dst_tr.X = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_X_PITCH-1].X;
	dst_tr.Y = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_X_PITCH-1].Y;
	
	/* the coordinate of Hood view bottom left point */
	dst_bl.X = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X;
	dst_bl.Y = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y;

	/* the coordinate of Hood view bottom right point */
	dst_br.X = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM-1].X;
	dst_br.Y = (H)DstScreenCoord_3h_ori[D_UF_3H_DST_NUM-1].Y;



	/* the coordinate of Hood view blending top left point */
	dst_tl_b.X = (H)DstScreenCoord_3h[0].X;
	dst_tl_b.Y = (H)DstScreenCoord_3h[0].Y;
	
	/* the coordinate of Hood view blending top right point */
	dst_tr_b.X = (H)DstScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X;
	dst_tr_b.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y;
	
	/* the coordinate of Hood view blending bottom left point */
	dst_bl_b.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X;
	dst_bl_b.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y;

	/* the coordinate of Hood view blending bottom right point */
	dst_br_b.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X;
	dst_br_b.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y;

	

	/* the hexagon of the front camera */
	/* the top rectangle of the front camera */
	fl_pos.X = 0;
	fl_pos.Y = 0;
	fr_pos.X = E_VI_DISP_LAYOUT_WIDTH_MAX;
	fr_pos.Y = fl_pos.Y;
	rr_pos.X = E_VI_DISP_LAYOUT_WIDTH_MAX;
	rr_pos.Y = (H)m_vi_skeleton_blend_sideline_layout.H2; /* Y coordinate of Blending left bottom point */
	rl_pos.X = fl_pos.X;
	rl_pos.Y = rr_pos.Y;
	(void)vi_app_nosig_mask_set_quadrilateral( E_VI_RECT_NOSIGNAL_MASK_SKELVIEW_FRONT_T, (const S_VI_COORDINATE *)&fl_pos, (const S_VI_COORDINATE *)&fr_pos,
																						 (const S_VI_COORDINATE *)&rr_pos, (const S_VI_COORDINATE *)&rl_pos);	

	/* the bottom quadrilateral of the front camera */
	fl_pos.X = 0;
	fl_pos.Y = (H)m_vi_skeleton_blend_sideline_layout.H2; 
	fr_pos.X = E_VI_DISP_LAYOUT_WIDTH_MAX;
	fr_pos.Y = (H)m_vi_skeleton_blend_sideline_layout.H2; 
	rr_pos.X = dst_tr.X;
	rr_pos.Y = dst_tr.Y;
	rl_pos.X = dst_tl.X;
	rl_pos.Y = dst_tl.Y;
	(void)vi_app_nosig_mask_set_quadrilateral( E_VI_RECT_NOSIGNAL_MASK_SKELVIEW_FRONT_B, (const S_VI_COORDINATE *)&fl_pos, (const S_VI_COORDINATE *)&fr_pos,
																						 (const S_VI_COORDINATE *)&rr_pos, (const S_VI_COORDINATE *)&rl_pos);																					

	/* the quadrilateral of the left camera */
	fl_pos.X = 0;
	fl_pos.Y = (H)m_vi_skeleton_blend_frline_layout.H2;/* Y coordinate of Blending left top point */
	fr_pos.X = dst_tl.X;
	fr_pos.Y = dst_tl.Y;
	rr_pos.X = dst_bl.X;
	rr_pos.Y = dst_bl.Y;
	rl_pos.X = 0;
	rl_pos.Y = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	(void)vi_app_nosig_mask_set_quadrilateral( E_VI_RECT_NOSIGNAL_MASK_SKELVIEW_LEFT, (const S_VI_COORDINATE *)&fl_pos, (const S_VI_COORDINATE *)&fr_pos,
																					  (const S_VI_COORDINATE *)&rr_pos, (const S_VI_COORDINATE *)&rl_pos);

	/* the quadrilateral of the right camera */
	fl_pos.X = dst_tr.X;
	fl_pos.Y = dst_tr.Y;
	fr_pos.X = E_VI_DISP_LAYOUT_WIDTH_MAX;
	fr_pos.Y = (H)m_vi_skeleton_blend_frline_layout.H2;
	rr_pos.X = E_VI_DISP_LAYOUT_WIDTH_MAX;
	rr_pos.Y = E_VI_DISP_LAYOUT_HEIGHT_MAX;
	rl_pos.X = dst_br.X;
	rl_pos.Y = dst_br.Y;
	(void)vi_app_nosig_mask_set_quadrilateral( E_VI_RECT_NOSIGNAL_MASK_SKELVIEW_RIGHT, (const S_VI_COORDINATE *)&fl_pos, (const S_VI_COORDINATE *)&fr_pos,
																					   (const S_VI_COORDINATE *)&rr_pos, (const S_VI_COORDINATE *)&rl_pos);
	/*the quadrilateral of the hood view */
 	fl_pos.X = dst_tl_b.X;
	fl_pos.Y = dst_tl_b.Y;
	fr_pos.X = dst_tr_b.X;
	fr_pos.Y = dst_tr_b.Y;
	rr_pos.X = dst_br_b.X;
	rr_pos.Y = dst_br_b.Y;
	rl_pos.X = dst_bl_b.X;
	rl_pos.Y = dst_bl_b.Y;
	(void)vi_app_nosig_mask_set_quadrilateral( E_VI_RECT_NOSIGNAL_MASK_SKELVIEW_HOOD, (const S_VI_COORDINATE *)&fl_pos, (const S_VI_COORDINATE *)&fr_pos,
																					   (const S_VI_COORDINATE *)&rr_pos, (const S_VI_COORDINATE *)&rl_pos);   
																					   
}

/*_FCHK_
 *==============================================================================================
 *	関数名		vi_app_uf_InitMakeArea
 *	機能		IPAデッドレコニングの更新により、駐車枠座標を自車を原点とする座標に変換
 *	引数		const S_VI_CAR_COMMON_PARAM_TBL	*car_add		(車両)共有パラメータテーブルの先頭アドレス
 *	戻り値		成功（E_VI_SUCCESS）/失敗（E_VI_FAILURE）
 *	備考		※AVM_IPAでの元関数：hm_gr_UpdatePos_ipa()
 *	備考		※R_Carでの元関数：vi_app_IPA_UpdatePos()
 *	作成日		2012.06.01
 *	最終更新日	2015.04.06 共有オブジェ参照先を変更
 *	逸脱手続日  
 *	
 *----------------------------------------------------------------------------------------------
 *	実施日付		判定		担当
 *----------------------------------------------------------------------------------------------
 *	2012.10.11		○			arayay
 *----------------------------------------------------------------------------------------------
 *	確認項目		確認内容
 *----------------------------------------------------------------------------------------------
 *	分岐確認		ケース分岐のみ
 *	無限ループ		なし
 *	変数初期化		グローバル変数初期化OK、内部変数は使用前にデータ登録あり
 *	変数領域外		領域外への書き込み処理なし
 *	入力			なし
 *	出力			なし
 *	検出修正数		0
 *---------------------------------------------------------------------------------------------
 *	テスト数		1			UT 不具合数			0			ICE 不具合数			0
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_InitMakeArea( S_VI_CAR_COMMON_PARAM_TBL *car_add )
{

	S_VI_F_COORDINATE tmp[D_VI_UF_RECT_MAX];	/* 座標作成一時領域用 */
	S_VI_F_COORDINATE tmp_3h[D_VI_UF_RECT_MAX];
	int i,j;
	float_t ftmpWH, fDx, fDy, fDx_ori, fDy_ori;
	sshort stmpWH;
	float_t center_y = 1.635f;
	float_t skelton_overlap_width = 0.25f; //Expand the skelton view area for blending, this area will be blended with front & left & right camera video
	slong rcode;	
	
	/* 引数チェック */
	if( NULL == car_add )
	{
		return E_VI_FAILURE;
	}
	else
	{
		/* No Operation */
	}

	/* VIEWの座標 前輪車軸を中心(0,0)とした車両サイズの座標作成 */
	/*                 －                    */
	/*                (Ｙ)                   */
	/*              前 ↑                    */
	/*               ─｜─                  */
	/*              ｜ ｜ ｜                 */
	/*              ｜ ｜ ｜                 */
	/*     -(X)<------------------->(X)+     */
	/*              ｜ ｜ ｜                 */
	/*               ─｜─                  */
	/*                 ↓                    */
	/*                (Ｙ)                   */
	/*                 ＋                    */
	/* 左上 */
	tmp[D_VI_UF_RECT_LT].X = -( car_add->car_data.Width / 2.0F );
	tmp[D_VI_UF_RECT_LT].Y = - car_add->car_data.Faxle;
	/* 右上 */
	tmp[D_VI_UF_RECT_RT].X = ( car_add->car_data.Width / 2.0F );
	tmp[D_VI_UF_RECT_RT].Y = - car_add->car_data.Faxle;
	/* 左下 */
	tmp[D_VI_UF_RECT_LB].X = -( car_add->car_data.Width / 2.0F );
	tmp[D_VI_UF_RECT_LB].Y = car_add->car_data.Wheelbase + car_add->car_data.Raxle;
	/* 右下 */
	tmp[D_VI_UF_RECT_RB].X = ( car_add->car_data.Width / 2.0F );
	tmp[D_VI_UF_RECT_RB].Y = car_add->car_data.Wheelbase + car_add->car_data.Raxle;

	/* 座標から一定値OFFSET */
	/* 左上 */
	tmp[D_VI_UF_RECT_LT].X -= E_VI_UF_OFFSET_SIDE;
	tmp[D_VI_UF_RECT_LT].Y -= E_VI_UF_OFFSET_FR;
	/* 右上 */
	tmp[D_VI_UF_RECT_RT].X += E_VI_UF_OFFSET_SIDE;
	tmp[D_VI_UF_RECT_RT].Y -= E_VI_UF_OFFSET_FR;
	/* 左下 */
	tmp[D_VI_UF_RECT_LB].X -= E_VI_UF_OFFSET_SIDE;
	tmp[D_VI_UF_RECT_LB].Y += E_VI_UF_OFFSET_FR;
	/* 右下 */
	tmp[D_VI_UF_RECT_RB].X += E_VI_UF_OFFSET_SIDE;
	tmp[D_VI_UF_RECT_RB].Y += E_VI_UF_OFFSET_FR;

	/* 相対座標を画面座標に変換 */
	(void)vi_app_uf_convert_ScreenCoord( tmp, DstScreenCoord, car_add );
	// 

	//四捨五入する
	//if(debug_45flag == 1)
	//{
		for(i=0; i < D_VI_UF_RECT_MAX; i++)
		{
			DstScreenCoord[i].X = CMN_F32ABSROUND(DstScreenCoord[i].X);
			DstScreenCoord[i].Y = CMN_F32ABSROUND(DstScreenCoord[i].Y);
		}
	//}
	
	/* No762DEBUG */
	/* LBを固定して、幅の4N分RB,RTのX座標を変換 */
	DstScreenCoord[D_VI_UF_RECT_LB].X = (float_t)((sshort)DstScreenCoord[D_VI_UF_RECT_LB].X);
	DstScreenCoord[D_VI_UF_RECT_LT].X = DstScreenCoord[D_VI_UF_RECT_LB].X;
	ftmpWH = DstScreenCoord[D_VI_UF_RECT_RB].X - DstScreenCoord[D_VI_UF_RECT_LB].X;
	stmpWH = (sshort)(ftmpWH - ((sshort)(ftmpWH) % 4));
	DstScreenCoord[D_VI_UF_RECT_RB].X = (float_t)((sshort)DstScreenCoord[D_VI_UF_RECT_LB].X) + (float_t)stmpWH;
	DstScreenCoord[D_VI_UF_RECT_RT].X = (float_t)((sshort)DstScreenCoord[D_VI_UF_RECT_LB].X) + (float_t)stmpWH;
	
	/* バックアップヘッダ設定(幅) */
	save_head.w = (ushort)abs(stmpWH);
	
	/* LBを固定して、幅の4N分RB,RTのY座標を変換 */
	DstScreenCoord[D_VI_UF_RECT_LB].Y = (float_t)((sshort)DstScreenCoord[D_VI_UF_RECT_LB].Y);
	DstScreenCoord[D_VI_UF_RECT_RB].Y = DstScreenCoord[D_VI_UF_RECT_LB].Y;
	ftmpWH = DstScreenCoord[D_VI_UF_RECT_LT].Y - DstScreenCoord[D_VI_UF_RECT_LB].Y;
	stmpWH = (sshort)(ftmpWH - ((sshort)(ftmpWH) % 4));
	DstScreenCoord[D_VI_UF_RECT_LT].Y = (float_t)((sshort)DstScreenCoord[D_VI_UF_RECT_LB].Y) + (float_t)stmpWH;
	DstScreenCoord[D_VI_UF_RECT_RT].Y = (float_t)((sshort)DstScreenCoord[D_VI_UF_RECT_LB].Y) + (float_t)stmpWH;

	/* バックアップヘッダ設定(幅)、開始座標*/
	save_head.h = (ushort)abs(stmpWH);
	save_head.startX = (sshort)DstScreenCoord[D_VI_UF_RECT_LT].X;
	save_head.startY = (sshort)DstScreenCoord[D_VI_UF_RECT_LT].Y;
	
	dbg_printfSync("[View]##### vi_app_uf_InitMakeArea w = %d h = %d (%d,%d)\n",
	save_head.w, save_head.h, save_head.startX, save_head.startY);	

	/* 相対座標をSrc相対座標として登録 */
	memcpy( SrcLocalCoord, tmp , sizeof(tmp));

	/* RCG相対座標からSrc画面座標に変換(ここはいらんかも、、変数の初期化目的) */
	(void)vi_app_uf_convert_ScreenCoord( tmp, SrcScreenCoord, car_add );

	/* 3d hoodview dst coordinates start */
	fDx = (car_add->car_data.Width + skelton_overlap_width)/ (D_UF_3H_DST_X_PITCH - 1);
	//fDy = (D_UF_3H_DST_F_DIST + car_add->car_data.Faxle + D_UF_3H_DST_R_DIST) / (D_UF_3H_DST_Y_PITCH - 1);
	fDy = (car_add->car_data.Fr_kerare + car_add->car_data.Faxle + skelton_overlap_width + car_add->car_data.WheelDiameter/2.0f) / (D_UF_3H_DST_Y_PITCH - 1);
	fDx_ori = (car_add->car_data.Width) / (D_UF_3H_DST_X_PITCH - 1);
	fDy_ori = (car_add->car_data.Fr_kerare + car_add->car_data.Faxle + car_add->car_data.WheelDiameter/2.0f) / (D_UF_3H_DST_Y_PITCH - 1);
	for(i = 0; i < D_UF_3H_DST_Y_PITCH; i++)
	{
		for(j = 0; j < D_UF_3H_DST_X_PITCH; j++)
		{
			// VIEWの座標 前輪車軸を中心(0,0)
			DstScreenCoord_3h[i*D_UF_3H_DST_X_PITCH + j].X = (float_t)(- ((car_add->car_data.Width + skelton_overlap_width)/ 2.0f) + (float_t)j*fDx);
			DstScreenCoord_3h[i*D_UF_3H_DST_X_PITCH + j].Y = (float_t)(- (car_add->car_data.Fr_kerare + skelton_overlap_width + car_add->car_data.Faxle) + (float_t)i*fDy);
			DstScreenCoord_3h_ori[i*D_UF_3H_DST_X_PITCH + j].X = (float_t)(- ((car_add->car_data.Width) / 2.0f) + (float_t)j*fDx_ori);
			DstScreenCoord_3h_ori[i*D_UF_3H_DST_X_PITCH + j].Y = (float_t)(- (car_add->car_data.Fr_kerare + car_add->car_data.Faxle) + (float_t)i*fDy_ori);
			// 画像認識（SPS）座標 後輪車軸を中心(0,0)
			RcgLocalCoord_3h[i*D_UF_3H_DST_X_PITCH + j].X = 
				(float_t)((car_add->car_data.Fr_kerare + car_add->car_data.Faxle + skelton_overlap_width + car_add->car_data.Wheelbase) - (float_t)i*fDy);
			RcgLocalCoord_3h[i*D_UF_3H_DST_X_PITCH + j].Y = (float_t)(((car_add->car_data.Width + skelton_overlap_width)/ 2.0f) - (float_t)j*fDx);
		}	
	}

	dbg_printfSync("Fr_kerare[%f]WheelDiameter[%f]\n",car_add->car_data.Fr_kerare,car_add->car_data.WheelDiameter);

	// dst sreen coordinate
	dbg_printfSync("DSTw LT[%f][%f] RT[%f][%f] LB[%f][%f] RB[%f][%f]\n",
		DstScreenCoord_3h[0].X,DstScreenCoord_3h[0].Y,
		DstScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X,DstScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y,
		DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X,DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y,
		DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X,DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y);

	//rcode = vi_mid_CamDistortion_projection_3D(&DstScreenCoord_3h[0], D_UF_3H_DST_NUM, E_VI_LINE_CALC_HOOD);
	//rcode = vi_mid_CamDistortion_projection_3D(&DstScreenCoord_3h_ori[0], D_UF_3H_DST_NUM, E_VI_LINE_CALC_HOOD);
	rcode = tl__GetSkeletonCamPara();
	if (E_VI_SUCCESS != rcode) {
		dbg_printfSync("vi_app_uf_InitMakeArea tl__GetSkeletonCamPara  erro\n");
		return rcode;
	}
	for(i=0; i < D_UF_3H_DST_NUM; i++) {
		rcode = vi_mid_skeleton_CoodTransformWorldToScreen((uchar)E_VI_LINE_CALC_HOOD, &DstScreenCoord_3h[i]);
		if (E_VI_SUCCESS != rcode) {
			dbg_printfSync("vi_app_uf_InitMakeArea vi_mid_skeleton_CoodTransformWorldToScreen  erro\n");
			break;
		}
		rcode = vi_mid_skeleton_CoodTransformWorldToScreen((uchar)E_VI_LINE_CALC_HOOD, &DstScreenCoord_3h_ori[i]);
		if (E_VI_SUCCESS != rcode) {
			dbg_printfSync("vi_app_uf_InitMakeArea vi_mid_skeleton_CoodTransformWorldToScreen  erro\n");
			break;
		}
	}
	rcode = vi_app_uf_adapt_InitArea(&DstScreenCoord_3h[0], E_VI_DISP_LAYOUT_WIDTH_MAX-1, E_VI_DISP_LAYOUT_HEIGHT_MAX-1);
	if (E_VI_SUCCESS != rcode) {
		dbg_printfSync("vi_app_uf_InitMakeArea vi_app_uf_adapt_InitArea  erro\n");
		return rcode;
	}
	rcode = vi_app_uf_adapt_InitArea(&DstScreenCoord_3h_ori[0], E_VI_DISP_LAYOUT_WIDTH_MAX-1, E_VI_DISP_LAYOUT_HEIGHT_MAX-1);
	if (E_VI_SUCCESS != rcode) {
		dbg_printfSync("vi_app_uf_InitMakeArea vi_app_uf_adapt_InitArea  erro\n");
		return rcode;
	}
	dbg_printfSync("DST LT[%f][%f] RT[%f][%f] LB[%f][%f] RB[%f][%f]\n",
		DstScreenCoord_3h[0].X,DstScreenCoord_3h[0].Y,
		DstScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X,DstScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y,
		DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X,DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y,
		DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X,DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y);

	if (E_VI_SUCCESS != rcode)
	{
		return E_VI_FAILURE;
	}

	//四捨五入する
	for(i=0; i < D_UF_3H_DST_NUM; i++)
	{
		DstScreenCoord_3h[i].X = CMN_F32ABSROUND(DstScreenCoord_3h[i].X);
		DstScreenCoord_3h[i].Y = CMN_F32ABSROUND(DstScreenCoord_3h[i].Y);
		DstScreenCoord_3h_ori[i].X = CMN_F32ABSROUND(DstScreenCoord_3h_ori[i].X);
		DstScreenCoord_3h_ori[i].Y = CMN_F32ABSROUND(DstScreenCoord_3h_ori[i].Y);	
	}	

	//dbg_printfSync("3d hoodview Local DST LT[%f][%f] RT[%f][%f] LB[%f][%f] RB[%f][%f]\n",DstScreenCoord_3h[D_VI_UF_RECT_LT].X,DstScreenCoord_3h[D_VI_UF_RECT_LT].Y,DstScreenCoord_3h[D_VI_UF_RECT_RT].X,DstScreenCoord_3h[D_VI_UF_RECT_RT].Y,
	//	DstScreenCoord_3h[D_VI_UF_RECT_LB].X,DstScreenCoord_3h[D_VI_UF_RECT_LB].Y,DstScreenCoord_3h[D_VI_UF_RECT_RB].X,DstScreenCoord_3h[D_VI_UF_RECT_RB].Y);		

	/* 3d hoodview dst coordinates end */

	/* 画像認識（SPS）座標 後輪車軸を中心(0,0)とした車両サイズの座標作成 */
	/*                 ＋                   */
	/*               （Ｙ）                   */
	/*               ─↑───              */
	/*              ｜ ｜     ｜前           */
	/* －（Ｘ）＜―――――――――＞（Ｘ）＋*/
	/*              ｜ ｜     ｜             */
	/*               ─↓───              */
	/*                (Ｙ)                   */
	/*                 －                    */
	/* 左上(左前) */
#if 0
	RcgLocalCoord[D_VI_UF_RECT_LT].X = car_add->car_data.Wheelbase + car_add->car_data.Faxle;
	RcgLocalCoord[D_VI_UF_RECT_LT].Y = -( car_add->car_data.Width / 2.0F );
	/* 右上(右前) */
	RcgLocalCoord[D_VI_UF_RECT_RT].X = car_add->car_data.Wheelbase + car_add->car_data.Faxle;
	RcgLocalCoord[D_VI_UF_RECT_RT].Y = ( car_add->car_data.Width / 2.0F );
	/* 左下(左後) */
	RcgLocalCoord[D_VI_UF_RECT_LB].X = - car_add->car_data.Raxle;
	RcgLocalCoord[D_VI_UF_RECT_LB].Y = -(car_add->car_data.Width / 2.0F );
	/* 右下(右後) */
	RcgLocalCoord[D_VI_UF_RECT_RB].X = - car_add->car_data.Raxle;
	RcgLocalCoord[D_VI_UF_RECT_RB].Y = ( car_add->car_data.Width / 2.0F );

	/* 座標から一定値OFFSET */
	/* 左上 */
	RcgLocalCoord[D_VI_UF_RECT_LT].X += E_VI_UF_OFFSET_FR;
	RcgLocalCoord[D_VI_UF_RECT_LT].Y -= E_VI_UF_OFFSET_SIDE;
	/* 右上 */
	RcgLocalCoord[D_VI_UF_RECT_RT].X += E_VI_UF_OFFSET_FR;
	RcgLocalCoord[D_VI_UF_RECT_RT].Y += E_VI_UF_OFFSET_SIDE;
	/* 左下 */
	RcgLocalCoord[D_VI_UF_RECT_LB].X -= E_VI_UF_OFFSET_FR;
	RcgLocalCoord[D_VI_UF_RECT_LB].Y -= E_VI_UF_OFFSET_SIDE;
	/* 右下 */
	RcgLocalCoord[D_VI_UF_RECT_RB].X -= E_VI_UF_OFFSET_SIDE;
	RcgLocalCoord[D_VI_UF_RECT_RB].Y += E_VI_UF_OFFSET_FR;
#else
	RcgLocalCoord[D_VI_UF_RECT_LT].X = car_add->car_data.Wheelbase + car_add->car_data.Faxle;
	RcgLocalCoord[D_VI_UF_RECT_LT].Y = ( car_add->car_data.Width / 2.0F );
	/* 右上(右前) */
	RcgLocalCoord[D_VI_UF_RECT_RT].X = car_add->car_data.Wheelbase + car_add->car_data.Faxle;
	RcgLocalCoord[D_VI_UF_RECT_RT].Y = -( car_add->car_data.Width / 2.0F );
	/* 左下(左後) */
	RcgLocalCoord[D_VI_UF_RECT_LB].X = - car_add->car_data.Raxle;
	RcgLocalCoord[D_VI_UF_RECT_LB].Y = (car_add->car_data.Width / 2.0F );
	/* 右下(右後) */
	RcgLocalCoord[D_VI_UF_RECT_RB].X = - car_add->car_data.Raxle;
	RcgLocalCoord[D_VI_UF_RECT_RB].Y = -( car_add->car_data.Width / 2.0F );

	/* 座標から一定値OFFSET */
	/* 左上 */
	RcgLocalCoord[D_VI_UF_RECT_LT].X += E_VI_UF_OFFSET_FR;
	RcgLocalCoord[D_VI_UF_RECT_LT].Y += E_VI_UF_OFFSET_SIDE;
	/* 右上 */
	RcgLocalCoord[D_VI_UF_RECT_RT].X += E_VI_UF_OFFSET_FR;
	RcgLocalCoord[D_VI_UF_RECT_RT].Y -= E_VI_UF_OFFSET_SIDE;
	/* 左下 */
	RcgLocalCoord[D_VI_UF_RECT_LB].X -= E_VI_UF_OFFSET_FR;
	RcgLocalCoord[D_VI_UF_RECT_LB].Y += E_VI_UF_OFFSET_SIDE;
	/* 右下 */
	RcgLocalCoord[D_VI_UF_RECT_RB].X -= E_VI_UF_OFFSET_SIDE;
	RcgLocalCoord[D_VI_UF_RECT_RB].Y -= E_VI_UF_OFFSET_FR;

	vi_app_uf_RecSkeltonViewCoord();

#endif

	return E_VI_SUCCESS;

}





/*_FCHK_
 *==============================================================================================
 *	関数名		vi_app_uf_calcPos
 *	機能		引数により指定された座標に対して、移動と回転を行った座標を出力
 *	引数		const S_VI_F_COORDINATE * in_pnt		移動・回転を行う座標
 *				S_VI_F_COORDINATE * out_pnt			移動・回転を行った座標
 *				S_VI_UF_POS * pos		移動量、回転量
 *	戻り値		なし
 *	備考		※AVM_IPAでの元関数：hm_gr_calcPos_ipa()
 *	備考		※R_Carでの元関数：vi_app_IPA_calcPos()
 *	作成日		2012.06.01
 *	最終更新日	2012.06.01
 *	逸脱手続日  
 *	
 *----------------------------------------------------------------------------------------------
 *	実施日付		判定		担当
 *----------------------------------------------------------------------------------------------
 *	2012.10.11		○			arayay
 *----------------------------------------------------------------------------------------------
 *	確認項目		確認内容
 *----------------------------------------------------------------------------------------------
 *	分岐確認		ケース分岐のみ
 *	無限ループ		ループなし
 *	変数初期化		宣言時に初期化
 *	変数領域外		領域外への書き込み処理なし
 *	入力			ポインタのNULLチェックあり
 *	出力			なし
 *	検出修正数		0
 *---------------------------------------------------------------------------------------------
 *	テスト数		1			UT 不具合数			0			ICE 不具合数			0
 *==============================================================================================
_FCHK_*/
static void vi_app_uf_calcPos( const S_VI_F_COORDINATE * in_pnt, S_VI_F_COORDINATE * out_pnt, const S_VI_UF_POS * pos )
{
	double_t	tmp_x = 0.0F;
	double_t	tmp_y = 0.0F;

	if( ( NULL != in_pnt ) && ( NULL != out_pnt ) && ( NULL != pos ) )
	{
		/* 移動 */
		tmp_x = in_pnt->X - pos->pos_x;
		tmp_y = in_pnt->Y - pos->pos_y;

		/* 回転 */
		out_pnt->X = (float_t)( ( tmp_x * ( pos->cos_yaw ) ) - ( tmp_y * ( pos->sin_yaw ) ) );
		out_pnt->Y = (float_t)( ( tmp_x * ( pos->sin_yaw ) ) + ( tmp_y * ( pos->cos_yaw ) ) );
	}
}


/*_FCHK_
 *==============================================================================================
 *	関数名		vi_app_IPA_draw_rm_obs_top
 *	機能		トップビュー画面座標への変換
 *	引数		S_VI_F_COORDINATE *inCoord							計算前座標情報
 *				S_VI_F_COORDINATE *outCoord							計算後座標情報(画面座標)
 *				const S_VI_CAR_COMMON_PARAM_TBL	*car_add			(車両)共有パラメータテーブルの先頭アドレス
 *	備考		base（vi_app_IPA_draw_rm_obs_top）
 *	戻り値		成功（E_VI_SUCCESS）/失敗（E_VI_FAILURE）
 *	作成日		2018.06.01
 *	最終更新日	
 *	逸脱手続日	
 *	
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_convert_ScreenCoord( S_VI_F_COORDINATE *inCoord, S_VI_F_COORDINATE *outCoord, const S_VI_CAR_COMMON_PARAM_TBL *car_add )
{
	float_t		rcz_x = 0.0F;
	float_t		rcz_y = 0.0F;

	ushort		loop_cnt = 0U;

	/* 引数チェック */
	if(( NULL == inCoord ) || ( NULL == car_add ))
	{
		return E_VI_FAILURE;
	}
	else
	{
		/* No Operation */
	}

	/* 後輪車軸中心の描画座標を計算 */
	rcz_x = car_add->car_data.X_Origin;
//	rcz_y = car_add->car_data.Y_Origin + ( car_add->car_data.Wheelbase * car_add->car_data.Y_PixPerM );
	rcz_y = car_add->car_data.Y_Origin;

	/* 矩形分ループ */
	for( loop_cnt = 0; loop_cnt < D_VI_UF_RECT_MAX; loop_cnt++ )
	{
		/* 枠座標を計算 */
		outCoord[loop_cnt].X = (float_t)( ( inCoord[loop_cnt].X * car_add->car_data.X_PixPerM ) + rcz_x );
		outCoord[loop_cnt].Y = (float_t)( ( inCoord[loop_cnt].Y * car_add->car_data.Y_PixPerM ) + rcz_y );
	}
	
	return E_VI_SUCCESS;
}


/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_blend_disp_range_line
 * 機能        ブレンド範囲の枠を表示する（デバッグ用機能）
 *               ブレンド範囲を可視化するための関数。通常時は無効化されている。
 * 引数        const S_VI_TBL_DATA *apTbl
 * 戻り値      slong
 * 作成日      2016/03/31
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        const S_VI_TBL_DATA *apTbl
 *
 * 出力        d_debugDrawData
 *
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_DebugUF( const S_VI_TBL_DATA *apTbl , const S_VI_F_COORDINATE * psrc_rect, const S_VI_F_COORDINATE * pdst_rect)
{
	MM_STATUS				mm_sts = E_MM_STATUS_INVALID;
	uchar					msg[6];
	ER						ercd = E_OK;

	/* 引数チェック */
	if( NULL == apTbl )
	{
		dbg_printfSync("vi_app_blend_disp_range_line err parm null.\n");
		return E_VI_FAILURE;
	}


	/* 設定する領域の全クリア */
	memset( &d_debugDrawData, 0x00, (size_t)sizeof(struct_MM_Data_View_Debug_Info) );

	/* コマンド数初期化 */
	d_debugDrawData.command_num = 0U;


	/* DST画面座標の枠表示(青) */
	(void)vi_app_uf_DebugRect( pdst_rect, &d_debugDrawData, E_VI_LINE_COLOR_BLUE, E_VI_LINE_NORMAL_WIDTH );

	/* ソース画面座標の枠表示(オレンジ) */
	(void)vi_app_uf_DebugRect( psrc_rect, &d_debugDrawData, E_VI_LINE_COLOR_ORANGE, 4 );

	/* ブレンドの範囲線情報が設定出来た場合のみ表示 */
	if( 0U < d_debugDrawData.command_num )
	{
		/* 共有オブジェクトにセット */
		mm_sts = MM_WRITE( E_MM_INFO_TYPE_VIEW, E_MM_DATA_TYPE_VIEW_DEBUG_INFO, d_debugDrawData );
		if( E_MM_STATUS_OK == mm_sts )
		{
			/* 成功した時だけ、メッセージを送信 */
			msg[0] = (uchar)RECEIVE_MESSAGE;
			msg[1] = (uchar)DEBUG_DRAW;
			msg[2] = (uchar)VIEW_TASK;

			ercd = cl_ipsnd_mbf( VIEW_BUFF, msg, (UINT)sizeof(msg) );
			if (E_OK != ercd)
			{
				/* 送信失敗してもデバッグ用の枠が表示されないだけなので、エラーログ出力のみとする */
				dbg_printfSync("vi_app_blend_disp_range_line cl_ipsnd_mbf error ret = %d\n", ercd);
			}
		}
	}

	return E_VI_SUCCESS;
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_DebugRect
 * 機能        指定した枠を指定した色で設定する（デバッグ用機能）
 * 引数        const S_VI_F_COORDINATE *rect, struct_MM_Data_View_Debug_Info *p_drawData, ulong colorg
 * 戻り値      slong
 * 作成日      2018/06/05
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        onst S_VI_F_COORDINATE *rect, ulong color
 *
 * 出力        struct_MM_Data_View_Debug_Info *p_drawData,
 *
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_DebugRect( const S_VI_F_COORDINATE *rect, struct_MM_Data_View_Debug_Info *p_drawData, ulong color, uchar width)
{
	uchar		line_num;

	/* 引数チェック */
	if((NULL == rect) || (NULL == p_drawData))
	{
		dbg_printfSync("vi_app_blend_set_range_line err parm null.\n");
		return E_VI_FAILURE;
	}

	/* デバッグ表示数チェック */
	if( 64U <= p_drawData->command_num )
	{
		/* デバッグ表示は最大64コしか表示できない */
		return E_VI_FAILURE;
	}

	/* 線情報の設定 */
	p_drawData->request[p_drawData->command_num].type = (uchar)E_MM_VI_DEBUG_LINE;
	p_drawData->request[p_drawData->command_num].width = width;;
	p_drawData->request[p_drawData->command_num].color = color;

	/* 座標情報の設定*/
	line_num = 0U;

	/* 左下 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)rect[D_VI_UF_RECT_LB].X;
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)rect[D_VI_UF_RECT_LB].Y;
	line_num++;

	/* 左上 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)rect[D_VI_UF_RECT_LT].X;
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)rect[D_VI_UF_RECT_LT].Y;
	line_num++;
	
	/* 右上 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)rect[D_VI_UF_RECT_RT].X;
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)rect[D_VI_UF_RECT_RT].Y;
	line_num++;

	/* 右下 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)rect[D_VI_UF_RECT_RB].X;
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)rect[D_VI_UF_RECT_RB].Y;
	line_num++;

	/* 囲むために再度左下 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)rect[D_VI_UF_RECT_LB].X;
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)rect[D_VI_UF_RECT_LB].Y;
	line_num++;

	/* ここから三角形作成 */
	/* 左上と右上の間 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)(((sshort)rect[D_VI_UF_RECT_LT].X + (sshort)rect[D_VI_UF_RECT_RT].X) / 2);
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)(((sshort)rect[D_VI_UF_RECT_LT].Y + (sshort)rect[D_VI_UF_RECT_RT].Y) / 2);
	line_num++;

	/* 右下 */
	p_drawData->request[p_drawData->command_num].coord[line_num].X = (sshort)rect[D_VI_UF_RECT_RB].X;
	p_drawData->request[p_drawData->command_num].coord[line_num].Y = (sshort)rect[D_VI_UF_RECT_RB].Y;
	line_num++;

	
	/* 線の頂点数登録 */
	p_drawData->request[p_drawData->command_num].line_num = line_num;

	/* デバッグ表示数をカウントアップ */
	p_drawData->command_num++;

	return E_VI_SUCCESS;
}



/******************************************************************************/
/**
 * @brief			自車矩形の4頂点座標演算
 *
 * @param[in]		ptCarSize_ex	:,車両サイズへのポインタ,-,[-],
 * @param[in]		ptMy_pnt		:,自車位置世界座標へのポインタ,-,[-],
 * @param[in]		nMyYaw			:,自車ヨー角,0<=value<3599,[0.1deg],
 * @param[out]		ptMyRect		:,自車矩形の4頂点座標テーブルへのポインタ,-,[-],
 * 
 * @retval			ACP_OK			:,正常終了,value=0,[-],
 * @retval			ACP_NG			:,異常終了,value=-1,[-],
 *
 * @date			2013.06.25		M.Imai			新規作成
 */
/******************************************************************************/
#if 0
slong ACP_CalcMyRect( const ACP_CARSIZE_EX_TBL* ptCarSize_ex, const S_VI_UF_PointWorld* ptMy_pnt, sshort nMyYaw, RG_CMN_RectangleWorld* ptMyRect )
{
	slong nRet = E_VI_SUCCESS;
	sint  nCnt = 0;
	S_VI_UF_PointWorld str_pnt[4];
	slong Length_mm;				/* 車両サイズ前後方向の長さ車両全長(単位：mm)					*/
	slong R_Edge_To_R_Wheel_mm;		/* 車両サイズ前後方向の長さ後輪車軸-車両後端の距離(単位：mm)	*/
	slong Width_Half_mm;			/* 車両サイズ左右方向の長さ車両全幅の半分(単位：mm)				*/
	float_t fYaw = (float_t)nMyYaw / 10.0f;

	/* 引数チェック */
	if (( NULL == ptMy_pnt )
		|| ( NULL == ptMyRect )
		)
	{
		ACP_DEBUG_PRINTF(E_ACP_LOG_LEVEL_ERR);
		return ( E_VI_FAILURE );
	}

	/* 車両サイズ取得 */
	Length_mm = (slong)ptCarSize_ex->Length_mm;
	R_Edge_To_R_Wheel_mm = (slong)ptCarSize_ex->R_Edge_To_R_Wheel_mm;
	Width_Half_mm = (slong)ptCarSize_ex->Width_Half_mm;

	/* 左前の回転前座標 */
	str_pnt[0].s32_x = ptMy_pnt->s32_x + Length_mm - R_Edge_To_R_Wheel_mm;
	str_pnt[0].s32_y = ptMy_pnt->s32_y + Width_Half_mm;

	/* 右前の回転前座標 */
	str_pnt[1].s32_x = ptMy_pnt->s32_x + Length_mm - R_Edge_To_R_Wheel_mm;
	str_pnt[1].s32_y = ptMy_pnt->s32_y - Width_Half_mm;

	/* 右後の回転前座標 */
	str_pnt[2].s32_x = ptMy_pnt->s32_x - R_Edge_To_R_Wheel_mm;
	str_pnt[2].s32_y = ptMy_pnt->s32_y - Width_Half_mm;

	/* 左後の回転前座標 */
	str_pnt[3].s32_x = ptMy_pnt->s32_x - R_Edge_To_R_Wheel_mm;
	str_pnt[3].s32_y = ptMy_pnt->s32_y + Width_Half_mm;

	for ( nCnt = 0; nCnt < 4; nCnt++ )
	{
		/* 自車位置座標を中心に回転した座標の演算 */
		nRet = ACP_Math_CalcRotatePoint( my_pnt, &(str_pnt[nCnt]), fYaw, &(ptMyRect->str_points[nCnt]) );
		if ( ACP_OK != nRet )
		{	
			ACP_DEBUG_PRINTF(E_ACP_LOG_LEVEL_ERR);
			return ( nRet );
		}
	}

	return ( ACP_OK );
}
#endif


slong vi_app_uf_CalcMyRect( const S_VI_F_COORDINATE* rcg_local_pnt, const S_VI_UF_DEADREC_INFO* drec, const S_VI_UF_DEADREC_INFO* drec_pre, S_VI_F_COORDINATE* src_local_conv_pnt)
{
	slong nRet = E_VI_SUCCESS;
	sint  nCnt = 0;

	S_VI_F_COORDINATE str_pnt[D_VI_UF_RECT_MAX];

	S_VI_F_COORDINATE my_pnt;		/* 今回の自車位置の矩形格納用 */
	//S_VI_F_COORDINATE my_pnt_pre;	/* 前回の自車位置の矩形格納用 */
	S_VI_F_COORDINATE wld_pnt;		/* 現在の自車位置の矩形を世界座標に変換する一時格納用変数 */
	S_VI_F_COORDINATE loc_pnt;		/* 現在の自車位置の矩形を相対座標に変換する一時格納用変数 */
	//S_VI_F_COORDINATE view_pnt;	/* 現在の自車位置の矩形をVIEWの座標に変換する一時格納用変数 */
	float_t fYaw;


	/* 引数チェック */
	if (( NULL == rcg_local_pnt )
		|| ( NULL == drec )
		|| ( NULL == src_local_conv_pnt )
		)
	{
		return ( E_VI_FAILURE );
	}

	// 今回の自車位置
	my_pnt.X = (float_t)drec->vp_rear_wpos_x;
	my_pnt.Y = (float_t)drec->vp_rear_wpos_y;
	fYaw = (float_t)drec->vp_rear_angle / 10.0f;

	/*Src領域の世界座標計算 */
	/*（viewの画面座標等の変換の単位は（浮動少数、m）なので、デドレコの座標単位(slong cm)にあわせる）*/
	/* 後輪車軸中心からの座標は計算済みなので、＋するだけ*/
	/* 左前の回転前座標 */
	str_pnt[D_VI_UF_RECT_LT].X = my_pnt.X + (float_t)(rcg_local_pnt[D_VI_UF_RECT_LT].X * 100.0F);
	str_pnt[D_VI_UF_RECT_LT].Y = my_pnt.Y + (float_t)(rcg_local_pnt[D_VI_UF_RECT_LT].Y * 100.0F);

	/* 右前の回転前座標 */
	str_pnt[D_VI_UF_RECT_RT].X = my_pnt.X + (float_t)(rcg_local_pnt[D_VI_UF_RECT_RT].X * 100.0F);
	str_pnt[D_VI_UF_RECT_RT].Y = my_pnt.Y + (float_t)(rcg_local_pnt[D_VI_UF_RECT_RT].Y * 100.0F);

	/* 左後の回転前座標 */
	str_pnt[D_VI_UF_RECT_LB].X = my_pnt.X + (float_t)(rcg_local_pnt[D_VI_UF_RECT_LB].X * 100.0F);
	str_pnt[D_VI_UF_RECT_LB].Y = my_pnt.Y + (float_t)(rcg_local_pnt[D_VI_UF_RECT_LB].Y * 100.0F);

	/* 右後の回転前座標 */
	str_pnt[D_VI_UF_RECT_RB].X = my_pnt.X + (float_t)(rcg_local_pnt[D_VI_UF_RECT_RB].X * 100.0F);
	str_pnt[D_VI_UF_RECT_RB].Y = my_pnt.Y + (float_t)(rcg_local_pnt[D_VI_UF_RECT_RB].Y * 100.0F);

	for ( nCnt = 0; nCnt < D_VI_UF_RECT_MAX; nCnt++ )
	{
		/* 自車位置座標を中心に回転した座標の演算 */
		nRet = vi_app_uf_Math_CalcRotatePoint( &my_pnt, &(str_pnt[nCnt]), fYaw, &wld_pnt );
		if ( E_VI_SUCCESS != nRet )
		{	
			return ( nRet );
		}

		/* 世界座標を、前回の自車位置情報（前回表示時のデドレコ情報）を使用して相対座標に変換する */
		vi_app_uf_Math_WldToLoc_point(&wld_pnt, drec_pre, &loc_pnt);

		/* 単位を元に戻す*/
		src_local_conv_pnt[nCnt].X = loc_pnt.X / 100.0F;
		src_local_conv_pnt[nCnt].Y = loc_pnt.Y / 100.0F;
		
	}

	vi_app_uf_ConvRcglocToViewloc(src_local_conv_pnt,src_local_conv_pnt);

	return ( E_VI_SUCCESS );
}


/******************************************************************************/
/**
 * @brief			任意座標を中心に回転した座標の演算
 *
 * @param[in]		ptOrigin_pnt	:,回転中心座標へのポインタ,-,[-],
 * @param[in]		ptIn_pnt		:,入力座標(回転させる座標)へのポインタ,-,[-],
 * @param[in]		fAngle			:,回転角度,0<=value<360,[deg],
 * @param[out]		ptOut_pnt		:,出力座標(回転後の座標)テーブルへのポインタ,-,[-],
 * 
 * @retval			ACP_OK			:,正常終了,value=0,[-],
 * @retval			ACP_NG			:,異常終了,value=-1,[-],
 *
 * @date			2013.06.25		M.Imai			新規作成
 */
/******************************************************************************/
slong vi_app_uf_Math_CalcRotatePoint( const S_VI_F_COORDINATE* ptOrigin_pnt, const S_VI_F_COORDINATE* ptIn_pnt, float_t fAngle, S_VI_F_COORDINATE* ptOut_pnt )
{
	float_t	fdx, fdy, fx, fy;
	float_t	fAngle_rad = CMN_DEG2RAD_F_F32( fAngle );	/* Deg⇒Rad変換 */

	/* 引数チェック */
	if (( NULL == ptOrigin_pnt )
		|| ( NULL == ptIn_pnt )
		|| ( NULL == ptOut_pnt )
		)
	{
		return ( E_VI_FAILURE );
	}

	fdx = (float_t)ptIn_pnt->X - (float_t)ptOrigin_pnt->X;
	fdy = (float_t)ptIn_pnt->Y - (float_t)ptOrigin_pnt->Y;

	fx = ( fdx * cosf(fAngle_rad)) - ( fdy * sinf(fAngle_rad)) + (float_t)ptOrigin_pnt->X;
	fy = ( fdx * sinf(fAngle_rad)) + ( fdy * cosf(fAngle_rad)) + (float_t)ptOrigin_pnt->Y;

	ptOut_pnt->X = fx;
	ptOut_pnt->Y = fy;

	return ( E_VI_SUCCESS );
}


/******************************************************************************/
/**
 * @brief		μAB世界座標を自車相対座標に変換する
 *					ACP_Math_WldToLoc_point
 * @param[in]	Wld_pnt		: ,世界座標,-,[-],
 * @param[in]	deadrec		: ,デドレコ情報,-,[-],
 * @param[out]	Loc_pnt		: ,自車中心相対座標,-,[-],
 * 
 * @retval		なし
 *
 * @date		17.07.12	F.Sano		SPS_WldToLoc_pointをベースに高速化
 */
/******************************************************************************/
void vi_app_uf_Math_WldToLoc_point(S_VI_F_COORDINATE *Wld_pnt, const S_VI_UF_DEADREC_INFO *deadrec, S_VI_F_COORDINATE *Loc_pnt)
{
	float_t local_x,local_y;
	float_t world_x,world_y;

	float_t tmp1 ;
	float_t angle ;
	float_t sin_angle ;
	float_t cos_angle ;

	/*相対距離算出*/
	local_x = (float_t)Wld_pnt->X - (float_t)deadrec->vp_rear_wpos_x;
	local_y = (float_t)Wld_pnt->Y - (float_t)deadrec->vp_rear_wpos_y;


	/*座標軸を自車方位に回転*/
	tmp1 = ((float_t)deadrec->vp_rear_angle / 10.0f);
	angle = CMN_DEG2RAD_F_F32( 360 - tmp1 );
	sin_angle = sinf(angle);
	cos_angle = cosf(angle);

	world_x = (local_x * cos_angle) - (local_y * sin_angle);
	world_y = (local_x * sin_angle) + (local_y * cos_angle);

	/*座標を整数値に直す*/
	Loc_pnt->X = world_x;
	Loc_pnt->Y = world_y;
}



/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_deadrecinfo
 *              Base(rg_get_deadrecinfo)
 * 機能        デッドレコニング情報取得
 * 引数        S_RG_DEADREC_INFO_BUF *pInfo
 * 戻り値      slong
 * 作成日      2012/12/5
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        共有オブジェクトから取得したデッドレコニング情報
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_deadrecinfo(S_VI_UF_DEADREC_INFO_BUF *s_drec_info)
{
	MM_STATUS rc = E_MM_STATUS_INVALID;
	struct_MM_Data_RC_Recog_Image_Data_Info mm_deadrec;
	uchar i = 0u;
	
	if (NULL == s_drec_info) {
		return E_VI_FAILURE;
	}

	/* 共有OBJより取得 */
	memset(&mm_deadrec, 0, (size_t)sizeof(mm_deadrec));
	rc = MM_READ(E_MM_INFO_TYPE_RC, E_MM_DATA_TYPE_RC_RECOG_IMAGE_DATA_INFO, mm_deadrec);
	if (E_MM_STATUS_OK != rc) {
		/* エラーログ */
	}
	s_drec_info->buf_size = E_VI_UF_DEADREC_BUFSIZE;
	s_drec_info->rw_point = mm_deadrec.index;
	for (i = 0u; i < E_VI_UF_DEADREC_BUFSIZE; i++)
	{
		// EntryAVMデッドレコ座標系から自律座標系に変換した座標を追加
		s_drec_info->deadrec_info[i].vp_rear_wpos_x = mm_deadrec.rc_info[i].vp_sps_wpos_x;
		s_drec_info->deadrec_info[i].vp_rear_wpos_y = mm_deadrec.rc_info[i].vp_sps_wpos_y;

		s_drec_info->deadrec_info[i].vp_rear_angle = mm_deadrec.rc_info[i].vp_sps_angle;
		//s_drec_info->deadrec_info[i].vp_rear_angle = 3600 - mm_deadrec.rc_info[i].vp_sps_angle;

		// 総移動距離を追加
		// デッドレコはmm単位．画認ミドルはcm単位（自律駐車用座標に合わせる）
		s_drec_info->deadrec_info[i].trip = mm_deadrec.rc_info[i].trip / 10.0f;
		s_drec_info->deadrec_info[i].tim = mm_deadrec.rc_info[i].tim;
		s_drec_info->deadrec_info[i].steering_angle = mm_deadrec.rc_info[i].steering_angle;
		s_drec_info->deadrec_info[i].vehicle_speed = mm_deadrec.rc_info[i].vehicle_speed;
		s_drec_info->deadrec_info[i].wspeed_r_re = mm_deadrec.rc_info[i].wspeed_r_re;
		s_drec_info->deadrec_info[i].wspeed_l_re = mm_deadrec.rc_info[i].wspeed_l_re;
		s_drec_info->deadrec_info[i].wspeed_r_fr = mm_deadrec.rc_info[i].wspeed_r_fr;
		s_drec_info->deadrec_info[i].wspeed_l_fr = mm_deadrec.rc_info[i].wspeed_l_fr;
		s_drec_info->deadrec_info[i].pls_r_re = mm_deadrec.rc_info[i].pls_r_re;
		s_drec_info->deadrec_info[i].pls_l_re = mm_deadrec.rc_info[i].pls_l_re;
		s_drec_info->deadrec_info[i].rot_radius = mm_deadrec.rc_info[i].rot_radius;
	}

	return E_VI_SUCCESS;
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_ConvRcglocToViewloc
 * 機能        画像認識座標とVIEWの座標ではY軸の成否が逆になるのでマイナス値をかける
 * 引数        S_VI_F_COORDINATE *rcgloc IN 変換元座標
 *             S_VI_F_COORDINATE *srcloc OUT 変換後座標
 * 戻り値      slong
 * 作成日      2012/12/5
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_ConvRcglocToViewloc( const S_VI_F_COORDINATE *rcgloc, S_VI_F_COORDINATE *srcloc)
{
	int i;

	/* 引数チェック */
	if (( NULL == rcgloc )
		|| ( NULL == srcloc )
		)
	{
		return ( E_VI_FAILURE );
	}

	/* 画像認識座標とVIEWの座標ではY軸の成否が逆になるのでマイナス値をかける */
	for( i = 0u; i < D_VI_UF_RECT_MAX; i++)
	{
		srcloc[i].X = rcgloc[i].X;
		srcloc[i].Y = -rcgloc[i].Y;
	}

	return E_VI_SUCCESS;
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_makeDSTRectBySRC
 * 機能        SRCの幅と高さをDSTに合わせる
 * 引数        S_VI_F_COORDINATE *dst IN  DST領域座標
 *             S_VI_F_COORDINATE *src IN  SRC領域座標
 *             S_VI_F_COORDINATE *out OUT 変換後座標
 * 戻り値      なし
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static void vi_app_uf_makeDSTRectBySRC(S_VI_F_COORDINATE *dst, S_VI_F_COORDINATE *src, S_VI_F_COORDINATE *out)
{
	float_t w, h;
	float_t anglex, angley;
	
	/* DSTの幅高さを求める */
	w = vi_app_uf_GetDistance(&dst[D_VI_UF_RECT_LB], &dst[D_VI_UF_RECT_RB]);
	h = vi_app_uf_GetDistance(&dst[D_VI_UF_RECT_LB], &dst[D_VI_UF_RECT_LT]);
	
	/* No762DEBUG */
	w = w + uf_debug_WAdd;
	
	/* LBからRBの角度を求める */
	anglex = vi_app_uf_GetAngle(&src[D_VI_UF_RECT_LB], &src[D_VI_UF_RECT_RB]);
	angley = vi_app_uf_GetAngle(&src[D_VI_UF_RECT_LB], &src[D_VI_UF_RECT_LT]);
	
	/* LB */
	out[D_VI_UF_RECT_LB].X = src[D_VI_UF_RECT_LB].X;
	out[D_VI_UF_RECT_LB].Y = src[D_VI_UF_RECT_LB].Y;
	
	/* RB */
	out[D_VI_UF_RECT_RB].X = (w * cosf(anglex)) + src[D_VI_UF_RECT_LB].X;
	out[D_VI_UF_RECT_RB].Y = (w * sinf(anglex)) + src[D_VI_UF_RECT_LB].Y;
	
	/* LT */
	out[D_VI_UF_RECT_LT].X = (h * cosf(angley)) + src[D_VI_UF_RECT_LB].X;
	out[D_VI_UF_RECT_LT].Y = (h * sinf(angley)) + src[D_VI_UF_RECT_LB].Y;
	
	/* RT */
	out[D_VI_UF_RECT_RT].X = (h * cosf(angley)) + out[D_VI_UF_RECT_RB].X;
	out[D_VI_UF_RECT_RT].Y = (h * sinf(angley)) + out[D_VI_UF_RECT_RB].Y;
	

	/* No762DEBUG */
	out[D_VI_UF_RECT_LB].X += uf_debug_XAdd;
	out[D_VI_UF_RECT_LB].Y += uf_debug_YAdd;
	/* RB */
	out[D_VI_UF_RECT_RB].X += uf_debug_XAdd;
	out[D_VI_UF_RECT_RB].Y += uf_debug_YAdd;
	/* LT */
	out[D_VI_UF_RECT_LT].X += uf_debug_XAdd;
	out[D_VI_UF_RECT_LT].Y += uf_debug_YAdd;
	/* RT */
	out[D_VI_UF_RECT_RT].X += uf_debug_XAdd;
	out[D_VI_UF_RECT_RT].Y += uf_debug_YAdd;

	
	
	return;
}

/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_GetAngle
 * 機能        2点間の角度取得
 * 引数        S_VI_F_COORDINATE *toCoord   IN  座標(TO)
 *             S_VI_F_COORDINATE *fromCoord IN  座標(FROM)
 * 戻り値      角度(ラジアン)
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static float_t vi_app_uf_GetAngle(S_VI_F_COORDINATE *toCoord, S_VI_F_COORDINATE *fromCoord)
{
	float_t x, y, t;
	
	x = fromCoord->X - toCoord->X;
	y = fromCoord->Y - toCoord->Y;
	
	t = (float_t)atan2(y, x);
	
	return t;
}
	
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_GetDistance
 * 機能        2点間の距離取得
 * 引数        S_VI_F_COORDINATE *toCoord   IN  座標(TO)
 *             S_VI_F_COORDINATE *fromCoord IN  座標(FROM)
 * 戻り値      距離
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static float_t vi_app_uf_GetDistance(S_VI_F_COORDINATE *toCoord, S_VI_F_COORDINATE *fromCoord)
{
	float_t vx;
	float_t vy;
	float_t leng;
	
	// ベクトルx座標計算
	vx = toCoord->X - fromCoord->X;
	// ベクトルy座標計算
	vy = toCoord->Y - fromCoord->Y;
	//線の長さlengを求める
	leng = sqrtf((vx * vx) + (vy * vy));
	
	return leng;
}

/* 自車下バックアップ *///add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_backup
 * 機能        自車下透過のバックアップ
 * 引数        なし
 * 戻り値      slong E_VI_SUCCESS:正常 E_VI_FAILURE:異常
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_backup( void )
{
	slong ret;
	float_t speed;
	
	/* デトレコ車速取得 */
	speed = vi_app_uf_GetSpeed();
	
	/* 停止中(前回速度が0kmで今回速度が0km)の場合は動いていないのでバックアップを行わない */
	if( (m_save_speed < UF_DRIVE_SPEED) && (speed < UF_DRIVE_SPEED) )
	{
		/* 車速保存 */
		m_save_speed = speed;
		return E_VI_SUCCESS;
	}
	
	/* 減速か速度維持のときだけバックアップを行う */
	if( speed > m_save_speed )
	{
		/* 車速保存 */
		m_save_speed = speed;
		return E_VI_SUCCESS;
	}
	
	/* 車速保存 */
	m_save_speed = speed;

	/* 車速が3km未満の場合バックアップを開始 */
	//if( speed < UF_BACKUP_START_SPEED)
	/* 車速が0.001km未満の場合バックアップを開始 */
	if( speed < UF_DRIVE_SPEED)
	{
		ret =  vi_app_uf_backup_mem();
		if( ret != E_VI_SUCCESS )
		{
			return ret;
		}
		//dbg_printfSync("[View]###### vi_app_uf_backup JISHATOUKA BACKUP DEBUGPRINT\n");
		/* 状態に停止を設定 */
		UfBackup_IGN_Flag = UF_IGN_STOP;
	}

	return E_VI_SUCCESS;
}

//描画バッファをwriteバッファにコピーする
//head    : ヘッダデータ
//orgAdr  : バックアップ元データ
//cpAdr   : writeバッファ
static void CopyBackUpBufToWriteBug(VI_S_BACKUPDATA *dt, uchar *orgAdr, uchar *cpAdr)
{
	ushort hcnt;
	sint pos, cnt;

	pos = dt->head.startY * DISP_W;
	cnt = 0;

	for(hcnt = 0; hcnt < dt->head.h; hcnt++)
	{
		pos += dt->head.startX;

		memcpy(&cpAdr[cnt], &orgAdr[pos], dt->head.w);

		cnt += dt->head.w;
		pos +=  (DISP_W -  dt->head.startX);
	}

}
//描画バッファをwriteバッファにコピーする
static void CopyBackUpBuf(uchar *dispBuf, VI_S_BACKUPDATA *writeBuf )
{
	SYSTIM		tm1, tm2;
	
	//時間測定
	tm1.ltime = 0UL;
	cl_get_tim( &tm1 );
	
	//writeデータにコピー(Y)
	CopyBackUpBufToWriteBug(writeBuf, dispBuf, writeBuf->data);

	//writeデータにコピー(UV)
	CopyBackUpBufToWriteBug(writeBuf, &dispBuf[DISP_W * DISP_H], &writeBuf->data[writeBuf->head.w * writeBuf->head.h]);

	//時間測定
	tm2.ltime = 0UL;
	cl_get_tim( &tm2 );
	dbg_printfSync("[View]###### JISHATOUKA CopyBackUpBuf time = %d\n", (tm2.ltime - tm1.ltime));
	
	return;

}

//add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_backup_mem
 * 機能        自車下透過メモリ出力
 * 引数        なし
 * 戻り値      slong E_VI_SUCCESS:正常 E_VI_FAILURE:異常
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_backup_mem( void )
{
	slong lret;
	ushort uret;
	S_VI_UF_BUF_T *pBuf;
    S_VI_UF_MEM_ITEM_T *pMem;
	ulong size;
	SYSTIM		tm1, tm2;
	ulong sizemax;
		
	dbg_printfSync("[View]###### JISHATOUKA BACKUP vi_app_uf_backup_mem START\n");
	
	/* データの書き込み情報 */
	pBuf = &pUft->out_plane_buf;
	pMem = &pBuf->mem_item[pBuf->curr_buf_index];
	//size = pBuf->mem_info.Height *  pBuf->mem_info.Width * (pBuf->mem_info.bpp / 8);

	/* ヘッダ設定 */
	memcpy(s_backupData->head.backup_id, backup_id, sizeof(backup_id));
	s_backupData->head.w = save_head.w;
	s_backupData->head.h = save_head.h;
	s_backupData->head.startX = save_head.startX;
	s_backupData->head.startY = save_head.startY;
	
	size = (s_backupData->head.h * s_backupData->head.w * 2) + sizeof(VI_S_BACKUPDATAHEAD);
	dbg_printfSync("[View]###### vi_app_uf_backup_mem Height = %d Width = %d xy = (%d,%d) size = %d\n",
		s_backupData->head.h, s_backupData->head.w, s_backupData->head.startX, s_backupData->head.startY, size);

	
	/* サイズチェック */
	sizemax = (DISP_W * DISP_H * 2) + sizeof(VI_S_BACKUPDATAHEAD);
	if(size > sizemax)
	{
		dbg_printfSync("[View]###### vi_app_uf_backup_mem size over size = %d sizemax = %d\n", size, sizemax);
		return E_VI_FAILURE;
	}
	
	/* Flash消去 */
	lret = vi_app_uf_flEraseSect(size);
	if( lret != E_VI_SUCCESS)
	{
		return E_VI_FAILURE;
	}
	
	//描画バッファをwriteバッファにコピーする
	CopyBackUpBuf((uchar*)(pMem->virt_addr), s_backupData);
	
	//時間測定
	tm1.ltime = 0UL;
	cl_get_tim( &tm1 );
	
	/* データの書き込み */
	uret = fl_SyncWrite((VP) E_UF_ADDR_RESERVED_ZONE_P, (VP)((const uchar*)s_backupData), size);
	if( uret != OK )
	{
		dbg_printfSync("[View]###### vi_app_uf_backup_mem fl_SyncWrite error ret = %d\n", uret);
		return E_VI_FAILURE;
	}

	//時間測定
	tm2.ltime = 0UL;
	cl_get_tim( &tm2 );

	dbg_printfSync("[View]###### JISHATOUKA BACKUP vi_app_uf_backup_mem fl_SyncWrite time = %d END\n", (tm2.ltime - tm1.ltime));
	return E_VI_SUCCESS;
	
}

//add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_flEraseSect
 * 機能        Flash消去
 * 引数        ulong size
 * 戻り値      slong E_VI_SUCCESS:正常 E_VI_FAILURE:異常
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_flEraseSect( ulong size )
{        
	ushort ret;
	ushort i;
	ulong sectorNo;
	ushort cnt;
	
	SYSTIM		tm1, tm2;	
	
	//時間測定
	tm1.ltime = 0UL;
	cl_get_tim( &tm1 );
	
	/*セクタ先頭番号取得 */
	sectorNo = E_FL_FLASH_SECTOR_BASE(E_UF_ADDR_RESERVED_ZONE_P);
	
	/* 消去セクタ数 */
	cnt = (ushort)((size / UF_FLASH_SECTOR_SIZE) + 1);
	
	dbg_printfSync("[View]###### vi_app_uf_flEraseSect SECTOR cnt = %d \n", cnt);
	
	for( i = 0UL; i < cnt; i++ )
	{
		/* セクタイレース */
		ret = fl_SyncEraseSect( sectorNo + i );
		if( ret != OK ){   //OK 1
			dbg_printfSync("[View]###### vi_app_uf_flEraseSect fl_SyncEraseSect() ERROR ret = %d \n", ret);
			return E_VI_FAILURE;
		}
	}
	
	//時間測定
	tm2.ltime = 0UL;
	cl_get_tim( &tm2 );
	dbg_printfSync("[View]######  vi_app_uf_flEraseSect time = %d\n", (tm2.ltime - tm1.ltime));
	
    return E_VI_SUCCESS;
}

	//readバッファを描画バッファにコピーする
	//startAdr               : バックアップ元データ
	//s_backupData.data   : readデータ
	//s_backupData.w      : readデータ幅
	//s_backupData.h      : readデータ高さ
	//s_backupData.startX : 設定X座標
	//s_backupData.startY : 設定Y座標
static void CopyReadBugToBackUpBuf(uchar *startAdr, uchar *cporg, ushort w, ushort h, ushort x, ushort y)
{
	ushort hcnt;
	sint pos, cnt;

	pos = y * DISP_W;
	cnt = 0;

	for(hcnt = 0; hcnt < h; hcnt++)
	{
		pos += x;
		memcpy(&startAdr[pos], &cporg[cnt], w);
		cnt += w;
		pos +=  (DISP_W - x);
	}
}

//readバッファを描画バッファにコピーする
static void CopyReadBuf(uchar *virt_addr, VI_S_BACKUPDATA *dt)
{
	//readバッファを描画バッファにコピーする(Y)
	CopyReadBugToBackUpBuf(virt_addr,
		dt->data, 
		dt->head.w,
		dt->head.h,
		(ushort)dt->head.startX,
		(ushort)dt->head.startY);

	//readバッファを描画バッファにコピーする(UV)
	CopyReadBugToBackUpBuf(&virt_addr[DISP_W * DISP_H],
		&dt->data[dt->head.w * dt->head.h], 
		dt->head.w,
		dt->head.h,
		(ushort)dt->head.startX,
		(ushort)dt->head.startY);

}

//add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_BackupRead
 * 機能        自車下透過バックアップデータ読み込み
 * 引数        なし
 * 戻り値      slong E_VI_SUCCESS:正常 E_VI_FAILURE:異常
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_BackupRead( void )
{
	ushort uret;
	S_VI_UF_BUF_T *pBuf;
	//S_VI_UF_BUF_T *pBufSub;// VSP2
	S_VI_UF_MEM_ITEM_T *pMem;
	S_VI_UF_MEM_ITEM_T *pMemSub;// VSP2
	ulong size;
	sshort i;

	dbg_printfSync("[View]###### vi_app_uf_BackupRead START \n");

	pBuf = &pUft->out_plane_buf;
	//pBufSub = &pUft->out_plane_bufSub;// VSP2
	//size = pBuf->mem_info.Height *  pBuf->mem_info.Width * (pBuf->mem_info.bpp / 8);

	/* ヘッダ読み込み */
	uret =  fl_SyncRead( (const void*)E_UF_ADDR_RESERVED_ZONE_P, (const void*)s_backupData, sizeof(VI_S_BACKUPDATAHEAD) );
	if( uret != OK )
	{
		dbg_printfSync("[View]###### vi_app_uf_memread fl_SyncRead head error ret = %d\n", uret);
		return E_VI_FAILURE;
	}

	/* IDチェック */
	for(i = 0; i < sizeof(backup_id); i++)
	{
		if(s_backupData->head.backup_id[i] != backup_id[i])
		{
			memset(s_backupData,0x00,(size_t)sizeof(VI_S_BACKUPDATA));
			dbg_printfSync("[View]###### vi_app_uf_memread fl_SyncRead error id [%x] - [%x] \n", s_backupData->head.backup_id[i], backup_id[i]);
			return E_VI_FAILURE;
		}
	}

	dbg_printfSync("[View]###### vi_app_uf_memread Height = %d Width = %d point(%d,%d)\n",
		s_backupData->head.h, s_backupData->head.w, s_backupData->head.startX, s_backupData->head.startY);

	size = (s_backupData->head.h * s_backupData->head.w * 2) + sizeof(VI_S_BACKUPDATAHEAD);
	if(size > sizeof(workBuf))
	{	
			memset(s_backupData,0x00,(size_t)sizeof(VI_S_BACKUPDATA));
			dbg_printfSync("[View]###### vi_app_uf_memread fl_SyncRead read size over error size = %d\n", size);
			return E_VI_FAILURE;
	}

	uret =  fl_SyncRead( (const void*)E_UF_ADDR_RESERVED_ZONE_P, (const void*)s_backupData, size );
	if( uret != OK )
	{
		memset(s_backupData,0x00,(size_t)sizeof(VI_S_BACKUPDATA));
		dbg_printfSync("[View]###### vi_app_uf_memread fl_SyncRead head error ret = %d\n", uret);
		return E_VI_FAILURE;
	}

	dbg_printfSync("[View]###### vi_app_uf_BackupRead END \n");

	return E_VI_SUCCESS;
}

//add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_BackupDisp
 * 機能        自車下透過バックアップデータ表示
 * 引数        なし
 * 戻り値      ushort
 * 作成日      2018/05/15
 * 最終更新日
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 *
 * 出力        なし
 *
 *==============================================================================================
_FCHK_*/
static slong vi_app_uf_BackupDisp( void )
{
	T_VI_VSP_PARAM_MAIN *pVsp = &m_vi_VspParamMain;
	//T_VI_VSP_PARAM_MAIN *pSub = &m_vi_VspParamSub;// VSP2
	S_VI_UF_MEM_ITEM_T *pItem;
	membmp_id_t out_a_m_id;
	slong lret=E_VI_SUCCESS;

	//dbg_printfSync("[vi_app_uf_BackupDisp]@@@ dl_id = x%x, dl_id_sub = x%x, stats(%d)\n", pUft->dl_id, pUft->dl_id_sub, UfBackup_IGN_Flag);//debug Test
	//エラーになったとき、何度も自車下透バックアップ読み込みを行わないように
	//状態を進める
	/* 状態に停止を設定 */
	UfBackup_IGN_Flag = UF_IGN_STOP;

	//自車下透バックアップ読み込み
	lret = vi_app_uf_BackupRead();
	if( lret != E_VI_SUCCESS)
	{
		return E_VI_FAILURE;
	}

	return E_VI_SUCCESS;

}

//add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_Set_IGNON
 * 機能        IGNON通知
 * 引数        なし
 * 戻り値      なし
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
void vi_app_uf_Set_IGNON( void )
{
	/* タスク初期化が完了していたら */
	if( UF_IGN_TASK_INIT == UfBackup_IGN_Flag )
	{
		/* 状態にIGNON受信設定 */
		UfBackup_IGN_Flag = UF_IGN_ON_RECV;
		dbg_printfSync("[View]##### vi_app_uf_Set_IGNON UF_IGN_ON_RECV \n");

	}
	else
	{
		dbg_printfSync("[View]vi_app_uf_Set_IGNON status error  UfBackup_IGN_Flag = %d \n", UfBackup_IGN_Flag);
	}
}

//add No762
/*_FCHK_
 *==============================================================================================
 * 関数名      vi_app_uf_GetSpeed
 * 機能        デトレコ車速取得
 * 引数        なし
 * 戻り値      float_t 車速
 * 作成日      2018/12/05
 * 最終更新日  
 *----------------------------------------------------------------------------------------------
 * 入力        なし
 * 
 * 出力        なし
 * 
 *==============================================================================================
_FCHK_*/
static float_t vi_app_uf_GetSpeed( void )
{
	MM_STATUS rc = E_MM_STATUS_INVALID;
	struct_MM_Data_RC_Recog_Image_Data_Info mm_deadrec;

	/* 共有OBJより取得 */
	memset(&mm_deadrec, 0, (size_t)sizeof(mm_deadrec));
	rc = MM_READ(E_MM_INFO_TYPE_RC, E_MM_DATA_TYPE_RC_RECOG_IMAGE_DATA_INFO, mm_deadrec);
	if (E_MM_STATUS_OK != rc) {
		dbg_printfSync("[View]vi_app_uf_GetSpeed MM_READ error\n");
		return 0.0f;
	}
	
#if 0	
	dbg_printfSync("[vi_app_uf_GetSpeed]### speed = %f ###\n", mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed);//debug
#endif
	/* 車速(単位：km/s) 判定 */
	 return mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed;
}

/* 状態フラグ取得 *///add No762
uchar vi_app_Get_UfBackup_IGN_Flag( void )
{
	return UfBackup_IGN_Flag;
}
/* 状態フラグ設定 *///add No762
void vi_app_Set_UfBackup_IGN_Flag( uchar flag )
{
	UfBackup_IGN_Flag = flag;
}
/* 状態フラグ無効設定 *///add No762
void vi_app_Stop_UfBackup_IGN_Flag( void )
{
	UfBackup_IGN_Flag = UF_IGN_MAX;
}
	
	
/* 車速デバッグ *///add No762
float_t vi_app_uf_Getvehicle_speed( void )
{
	return uf_vehicle_speed_dbg;
}
	
/* 自車下バックアップ */
	
	
/* No762DEBUG */
/* SRC画面座標取得 */
S_VI_F_COORDINATE * vi_app_uf_GetSrcScreenCoord( void )
{
	return SrcScreenCoord_DEBUG;
}
	
/* DST画面座標取得 */
S_VI_F_COORDINATE * vi_app_uf_GetDstScreenCoord( void )
{
	return DstScreenCoord_DEBUG;
}

/* SRC画面座標取得 */
T_IMRLIB_2DPOS * vi_app_uf_GetSrcScreenCoord_short( void )
{
	return pt_src_DEBUG;
}
	
/* DST画面座標取得 */
T_IMRLIB_2DPOS * vi_app_uf_GetDstScreenCoord_short( void )
{
	return pt_dst_DEBUG;
}

/* DST画面座標取得 */
char* vi_app_uf_GetName( void )
{
	return "KAKUDAI_NEW";
}

#if 0
	/* DSTとデバッグ値でSRCを作成する */
static void vi_app_uf_DebugSRC(S_VI_F_COORDINATE *dst, S_VI_F_COORDINATE *src, S_VI_F_COORDINATE *out)
{
	memcpy(out, dst, sizeof(S_VI_F_COORDINATE));
	
	dbg_printfSync("vi_app_uf_DebugSRC xyflag = %d val = %d\n", uf_debug_xyflag, uf_debug_xyVal);

	if (uf_debug_xyflag == 1)
	{
		/* X座標加算/減算 */
		out[D_VI_UF_RECT_LB].X -= uf_debug_xyVal;
		out[D_VI_UF_RECT_LT].X -= uf_debug_xyVal;
		out[D_VI_UF_RECT_RB].X += uf_debug_xyVal;
		out[D_VI_UF_RECT_RT].X += uf_debug_xyVal;
	}
	else if (uf_debug_xyflag == 2)
	{
		/* Y座標加算/減算 */
		out[D_VI_UF_RECT_LB].Y -= uf_debug_xyVal;
		out[D_VI_UF_RECT_LT].Y -= uf_debug_xyVal;
		out[D_VI_UF_RECT_RB].Y += uf_debug_xyVal;
		out[D_VI_UF_RECT_RT].Y += uf_debug_xyVal;
	}
	else if (uf_debug_xyflag == 3)
	{
		/* XY座標加算/減算 */
		out[D_VI_UF_RECT_LB].X -= uf_debug_xyVal;
		out[D_VI_UF_RECT_LT].X -= uf_debug_xyVal;
		out[D_VI_UF_RECT_RB].X += uf_debug_xyVal;
		out[D_VI_UF_RECT_RT].X += uf_debug_xyVal;

		out[D_VI_UF_RECT_LB].Y -= uf_debug_xyVal;
		out[D_VI_UF_RECT_LT].Y -= uf_debug_xyVal;
		out[D_VI_UF_RECT_RB].Y += uf_debug_xyVal;
		out[D_VI_UF_RECT_RT].Y += uf_debug_xyVal;
	}
	else if (uf_debug_xyflag == 4)
	{
		memcpy(out, dst, sizeof(S_VI_F_COORDINATE));
	}
	else
	{
		memcpy(out, src, sizeof(S_VI_F_COORDINATE));
	}

}
#endif
/* No762DEBUG */

static slong vi_app_uf_SetupBUBuf(S_VI_UF_BU_BUF_T *pBuf, uint32_t buf_num)
{
	uint32_t i;
	Error ercd;
	membmp_info_t *pInfo;
	S_VI_UF_MEM_ITEM_T *pMem;

	// パラメータチェック
	if( NULL == pBuf )
	{
		ERROR_PRINTF("\n");
		return E_VI_FAILURE;
	}

	if( (E_VI_UF_BU_FRAME_MAX < buf_num) || (0U == buf_num) )
	{
		ERROR_PRINTF("Param error buf_num=%d\n", buf_num);
		return E_VI_FAILURE;
	}
	
	pBuf->buf_num = buf_num;
	pInfo = &pBuf->mem_info;
	pMem = &pBuf->mem_item[0];

	for( i = 0U; i < pBuf->buf_num; i ++ )
	{
		pMem->mem_id = vi_allocImageMemoryNoInit( pInfo->Width, pInfo->Height, pInfo->bpp, pInfo->Attr );
		if( E_VI_MALLOC_FAILURE < pMem->mem_id )
		{
			ercd = memdrv_MemBitmapPhysAddrGet( pMem->mem_id, &pMem->phy_addr );
			if (Success != ercd)
			{
				ERROR_PRINTF("\n");
				pMem->phy_addr = 0U;
			}
			ercd = memdrv_MemBitmapVirtAddrGet( pMem->mem_id, &pMem->virt_addr );
			if (Success != ercd)
			{
				ERROR_PRINTF("\n");
				pMem->virt_addr = NULL;
			}
		}
		else
		{
			ERROR_PRINTF("\n");
			return E_VI_FAILURE;
		}

		pMem ++;

		// camera id
		pBuf->camera_id[i] = D_VI_VIN_CH_MAX;
		pBuf->first_cycle_cnt = 0;
	}
	
	if( MEMDRV_YUVSep == pInfo->Attr)
	{
		pBuf->uv_offset = pInfo->Stride * pInfo->Height;
	}
	else
	{
		// 未使用
		pBuf->uv_offset = 0U;
	}

	// バッファインデックスを初期化。
	pBuf->curr_buf_index = 0U;
	pBuf->next_buf_index = 0U;

	return E_VI_SUCCESS;
}
static slong vi_app_uf_ThroughviewBackup( void )
{
	static slong dist = 0;
	static uchar shiftPosition = E_MM_RC_SHIFT_POSITION_OFF;
	BOOL backupFlg = FALSE;
	slong eret;
	int32_t	ret_i32 = 0;
	uchar camera_dir = D_VI_VIN_CH_FRONT;
	T_IMRLSDRV_2DPOS	dst_pos = {0, 0};
	/* IMRの変換モードを設定 */
	uint32_t	mode = IMRLS_REG_TRIMR_TME | IMRLS_REG_TRIMR_BFE | IMRLS_REG_TRIMR_AUTOSG;
	//static ID	new_event_BU;
	S_VI_UF_BU_BUF_T* pBuf = &pUft->through_plane_buf;
	double fCurAngle , fCurRad , fBackupDist;
	const float_t fScale = 100.0;    /* Used for float compare */
	slong sDistMove = 0;
	slong sDistBackup = 0;
	slong sSpeed = 0;

	// get deadreco info
	// (void)vi_app_uf_deadrecinfo(&s_drec_info);

	// get shift gear
	shiftPosition = vi_app_uf_GetShiftPositon();
	sSpeed = (slong)(fScale * vi_app_uf_GetSpeed());

	fCurAngle = (double_t)pBuf->curDeadFR[pBuf->index_captured].steering_angle/ ( vidataP->car_add->car_data.Steer * E_VI_PERIGION );
	fCurRad = CMN_DEG2RAD_F_F32( fCurAngle );
	fBackupDist = D_UF_3H_BU_DIST/fabs(cos(fCurRad));

	// backup deside
	sDistMove = (slong)(fabs(pBuf->curDeadFR[pBuf->index_captured].trip - dist) * fScale);
	sDistBackup = (slong)(fBackupDist * fScale);
	if(sDistMove >= sDistBackup)
	{
		m_vi_event_BU = D_VI_FLG_FR_FRAME_UPDATE;
		camera_dir = D_VI_VIN_CH_FRONT;
		backupFlg = TRUE;

		pBuf->curr_buf_index = pBuf->next_buf_index;
		pBuf->next_buf_index = ( pBuf->next_buf_index + 1 ) % pBuf->buf_num;
	}
	else
	{
		backupFlg = FALSE;
	}
	if (shiftPosition == (uchar)E_MM_RC_SHIFT_POSITION_R)
	{
		pBuf->first_cycle_cnt = 0U;
		NotLiveBlinkCnt = 0U;
	}

	if(backupFlg)
	{
		if(uf_debug_flag[DBG_FLG_DEADRECO] > 0)
		{
			dbg_printfSync("[VIEW]vi_app_uf_ThroughviewBackup [%d][%d][%f][%d][%d][%d] \n",pBuf->index_captured,
				pBuf->curr_buf_index,
				pBuf->curDeadFR[pBuf->index_captured].trip,
				pBuf->curDeadFR[pBuf->index_captured].vp_rear_wpos_x,
				pBuf->curDeadFR[pBuf->index_captured].vp_rear_wpos_y,
				pBuf->curDeadFR[pBuf->index_captured].vp_rear_angle);
		}
		// camera id
		pBuf->camera_id[pBuf->curr_buf_index] = camera_dir;
		// save deadreco
		dist = (slong)pBuf->curDeadFR[pBuf->index_captured].trip;
		pBuf->deadrec_info[pBuf->curr_buf_index].vp_rear_wpos_x = pBuf->curDeadFR[pBuf->index_captured].vp_rear_wpos_x;
		pBuf->deadrec_info[pBuf->curr_buf_index].vp_rear_wpos_y = pBuf->curDeadFR[pBuf->index_captured].vp_rear_wpos_y;
		pBuf->deadrec_info[pBuf->curr_buf_index].vp_rear_angle = pBuf->curDeadFR[pBuf->index_captured].vp_rear_angle;
		pBuf->deadrec_info[pBuf->curr_buf_index].trip = pBuf->curDeadFR[pBuf->index_captured].trip;

		if( ( -1 != pUft->dl_id_bu) && ( NULL != imrlib_getDLPhysicalAddr( pUft->dl_id_bu ) ) )
		{
			/* Y映像の俯瞰変換 */
			ret_i32 = imrlsdrv_ExecuteExtDlAddr(
						pUft->imr_param.imr_ch,																					// IMRチャンネルNo
						imrlib_getDLPhysicalAddr( pUft->dl_id_bu ),															// ディスプレイリスト
#if defined( VIEW_OUTPUT_NTSC )		/* アナログ出力 */
						(int32_t)vsp_buf_id[camera_dir][vsp_buf_index[camera_dir]],												// 入力画像のBitmapID
#else
						(int32_t)vidataP->tbl_add->cvi_data[camera_dir].buf[pBuf->index_captured],											// 入力画像のBitmapID
#endif
						pBuf->mem_item[pBuf->curr_buf_index].mem_id,															// 出力画像のBitmapID
						&dst_pos,
						mode,
						IMRLSDRV_EXEC_Y,	// IMRLSDRV_EXEC_LUT_Y, 
						0,
						0 );
			if( E_OK != ret_i32 )
			{
				dbg_printfSync("[VIEW]vi_app_uf_ThroughviewBackup imrlsdrv_Execute(Through BackUp Y) error[%d]\n",ret_i32);
				return E_VI_FAILURE;
			}
			/* 変換の終了を待つ */
			ret_i32 = imrlsdrv_WaitEvent( pUft->imr_param.imr_ch );
			if( 0x01 != ( ret_i32 & 0x01 ) )		// レンダリング完了をチェック
			{
				dbg_printfSync("[VIEW]vi_app_uf_ThroughviewBackup imrlsdrv_WaitEvent(Through BackUp Y) error\n");
				return E_VI_FAILURE;
			}

			/* UV映像の俯瞰変換 */
			ret_i32 = imrlsdrv_ExecuteExtDlAddr(
						pUft->imr_param.imr_ch,																						// IMRチャンネルNo
						imrlib_getDLPhysicalAddr( pUft->dl_id_bu ),																// ディスプレイリスト
#if defined( VIEW_OUTPUT_NTSC )		/* アナログ出力 */
						(int32_t)vsp_buf_id[camera_dir][vsp_buf_index[camera_dir]],													// 入力画像のBitmapID
#else
						(int32_t)vidataP->tbl_add->cvi_data[camera_dir].buf[pBuf->index_captured],												// 入力画像のBitmapID
#endif
						pBuf->mem_item[pBuf->curr_buf_index].mem_id,																// 出力画像のBitmapID
						&dst_pos,
						mode,
						IMRLSDRV_EXEC_UV,
						0,
						0 );
			if( E_OK != ret_i32 )
			{
				dbg_printfSync("[VIEW]vi_app_uf_ThroughviewBackup imrlsdrv_Execute(Through BackUp UV) error\n");
				return E_VI_FAILURE;
			}

			/* 変換の終了を待つ */
			ret_i32 = imrlsdrv_WaitEvent( pUft->imr_param.imr_ch );
			if( 0x01 != ( ret_i32 & 0x01 ) )		// レンダリング完了をチェック
			{
				dbg_printfSync("[VIEW]vi_app_uf_ThroughviewBackup imrlsdrv_WaitEvent(Through BackUp UV) error\n");
				return E_VI_FAILURE;
			}				
			
			if (pBuf->first_cycle_cnt <= E_VI_UF_BU_FRAME_MAX)
			{
				pBuf->first_cycle_cnt++;
			}
		}
	}

	return E_VI_SUCCESS;
}
static slong vi_app_uf_loadMapFlash_BU()
{
	ushort				rc   = NG;
	T_IMRLIB_2DPOS		src_top_left = { 0, 0 };
	T_IMRLIB_2DPOS		dst_top_left = { 0, 0 };
	T_IMRLIB_2DPOS		pitch = { E_VI_CAM_DL_PITCH_X, E_VI_CAM_DL_PITCH_Y };	/* 4x3 ⇒ 4x4 へ修正 */
	T_IMRLIB_2DPOS		num;
	//T_IMRLIB_RECT		rc_clip_dst = { { UF_3H_DL_MOST_L, UF_3H_DST_T_Y }, { UF_3H_DL_MOST_R, UF_3H_DST_B_Y} };
	T_IMRLIB_RECT		clip = {{ 0, 0 }, { E_VI_DISP_LAYOUT_WIDTH_MAX, E_VI_DISP_LAYOUT_HEIGHT_MAX}};
	ID					tmp_dl_id;
	
	// 変換地点数を設定
	num.X = (H)(E_VI_CAMERA_LAYOUT_WIDTH_MAX / pitch.X + 1);
	num.Y = (H)(E_VI_CAMERA_LAYOUT_HEIGHT_MAX / pitch.Y + 1);

	//rc_clip_dst.lt.X = (H)(rc_clip_dst.lt.X - rc_clip_dst.lt.X % UF_DL_PITCH_X);
	//rc_clip_dst.lt.Y = (H)(rc_clip_dst.lt.Y - rc_clip_dst.lt.Y % UF_DL_PITCH_Y);
	//rc_clip_dst.rb.X = (H)(rc_clip_dst.rb.X + UF_DL_PITCH_X - rc_clip_dst.rb.X % UF_DL_PITCH_X);
	//rc_clip_dst.rb.Y = (H)(rc_clip_dst.rb.Y + UF_DL_PITCH_Y - rc_clip_dst.rb.Y % UF_DL_PITCH_Y);
	
	// flashからデータを読み込む
	rc = fl_SyncRead( (const void *)E_UF_ADDR_TRANSPARENT_MAP, (const void*)map_3h, (ulong)( (ulong)num.X * (ulong)num.Y * sizeof(T_IMRLIB_2DPOS) ) );
	if( OK != rc )
	{
		return -1;
	}

	/* ディスプレイリストを生成する（ソース：自動、デスト：指定） */
	tmp_dl_id = imrlib_makeDLAutoMeshSrc( src_top_left, pitch, num, map_3h, &clip );

	/* ディスプレイリストを生成する（ソース：指定、デスト：自動） */
	//tmp_dl_id = imrlib_makeDLAutoMeshDst( map_3h, pitch, num, dst_top_left, &clip );

	/* ディスプレイリストを生成する（ソース：指定、デスト：指定） */
	//tmp_dl_id = imrlib_makeDL_Hilbert( num, map_3h, d_vi_dst_local_buf, &clip, OFF );

	return tmp_dl_id;
	
}
static uchar vi_app_uf_GetShiftPositon(void)
{
	struct_MM_Data_RC_Shift_Pos new_position = {0U};
	MM_STATUS ret_mm = E_MM_STATUS_INVALID;
#ifdef SW_FUNC_ENABLE_TOW_MODE	//DCR045
	struct_MM_Data_SM_Tow_Mode mm_struct = {0};
	MM_STATUS stat;
#endif
	/* 共有オブジェからSHIFT情報取得 */
	ret_mm = MM_READ(E_MM_INFO_TYPE_RC, E_MM_DATA_TYPE_RC_SHIFT_POS, new_position);
	if (E_MM_STATUS_OK != ret_mm)
	{
		dbg_printfSync("%s", "[View] UF MM_READ(E_MM_DATA_TYPE_RC_SHIFT_POS) NG! \n");
	}
#ifdef SW_FUNC_ENABLE_TOW_MODE		//DCR045
	stat = MM_READ(E_MM_INFO_TYPE_SM, E_MM_DATA_TYPE_SM_TOW_MODE, mm_struct);
	if (E_MM_STATUS_OK != stat)
	{
	}
	new_position.ucRealShiftPos = (mm_struct.DriveModeState ==ON) ? E_MM_RC_SHIFT_POSITION_R : new_position.ucRealShiftPos;
#endif

	return new_position.ucRealShiftPos;
}

//judge the point whether is int the polygon
static int vi_app_uf_PointInPolygon(int nvert, double *vertx, double *verty, double testx, double testy)
{
  int i, j, result = 0;
  for (i = 0, j = nvert-1; i < nvert; j = i++) {
    if ( ((verty[i]>testy) != (verty[j]>testy)) &&
     (testx < (vertx[j]-vertx[i]) * (testy-verty[i]) / (verty[j]-verty[i]) + vertx[i]) )
       result = !result;
  }
  return result;
}

static slong vi_app_uf_IsInAvaiableArea(S_VI_UF_DEADREC_INFO_SIMPLE* pSrc , S_VI_UF_DEADREC_INFO_SIMPLE* pCoord , int i)
{
	BOOL bRet = TRUE;
	S_VI_UF_DEADREC_INFO_SIMPLE sSrc;
	S_VI_UF_DEADREC_INFO_SIMPLE sCoord;
	
	slong Src_world_x_new = 0, Src_world_y_new = 0 , Coord_world_x_new = 0, Coord_world_y_new = 0;
	slong Src_rel_x_new = 0, Src_rel_y_new = 0 , Coord_rel_x_new = 0, Coord_rel_y_new = 0 , tempX = 0, tempY = 0;
	slong Src_LF_world_x_new = 0 , Src_LF_world_y_new = 0;
	slong Src_RF_world_x_new = 0 , Src_RF_world_y_new = 0;
	slong Src_LR_world_x_new = 0 , Src_LR_world_y_new = 0;
	slong Src_RR_world_x_new = 0 , Src_RR_world_y_new = 0;
	S_VI_COM_CAR_PARAM_TBL * pBuf = &vidataP->car_add->car_data;
	
	slong coord_rotate_angle = 0;
	slong distance = 0;
	
	double_t fCoordAngle = 0.00;
	double_t coord_rotate_rad = 0.00;
	
	double_t fSrcAngle = 0.00;
	double_t src_rotate_rad = 0.00;

	double rate = 100.0f;

	double vertCoord_x[6] , vertCoord_y[6];
	int nPnpRet;
	slong lMin_x , lMax_x , lMin_y , lMax_y , lDistanceX , lDistanceY;

	memcpy(&sSrc , pSrc , sizeof(S_VI_UF_DEADREC_INFO_SIMPLE));
	memcpy(&sCoord , pCoord , sizeof(S_VI_UF_DEADREC_INFO_SIMPLE));

	//coord_rotate_angle = sCoord.vp_rear_angle/10;
	fCoordAngle = (double_t)sCoord.vp_rear_angle/10;
	fSrcAngle = (double_t)sSrc.vp_rear_angle/10;

	coord_rotate_rad = CMN_DEG2RAD_F_F32( 360.0 - fCoordAngle );
	src_rotate_rad = CMN_DEG2RAD_F_F32( 360.0 - fSrcAngle );

#if 0
	dbg_printfSync("pnp SRC[%d][%d][%d] COORD[%d][%d][%d]\n" , 
	sSrc.vp_rear_wpos_x , sSrc.vp_rear_wpos_y  , sSrc.vp_rear_angle  , 
	sCoord.vp_rear_wpos_x , sCoord.vp_rear_wpos_y  , sCoord.vp_rear_angle );
#endif	

	//from back center to front center,left is +,right is -?
	Coord_world_x_new = (slong)(sCoord.vp_rear_wpos_x + pBuf->Wheelbase * cos( coord_rotate_rad )* rate);
	Coord_world_y_new = (slong)(sCoord.vp_rear_wpos_y - pBuf->Wheelbase * sin( coord_rotate_rad ) * rate);
	
	Src_world_x_new = (slong)(sSrc.vp_rear_wpos_x + pBuf->Wheelbase * cos( src_rotate_rad ) * rate);
	Src_world_y_new = (slong)(sSrc.vp_rear_wpos_y - pBuf->Wheelbase * sin( src_rotate_rad ) * rate);
		                                                                          
	//move
	Src_rel_x_new = Src_world_x_new - Coord_world_x_new;
	Src_rel_y_new = Src_world_y_new - Coord_world_y_new;
	
	//rotate
	//Src_rel_x_new = Src_world_x_new * cos( coord_rotate_rad ) + Src_world_y_new * sin( coord_rotate_rad );
	//Src_rel_y_new = Src_world_y_new * cos( coord_rotate_rad ) - Src_world_x_new * sin( coord_rotate_rad );
	tempX = Src_rel_x_new;
	tempY = Src_rel_y_new;
	Src_rel_x_new = (slong)(tempX * cos( coord_rotate_rad) - tempY * sin(coord_rotate_rad));
	Src_rel_y_new = (slong)(tempX * sin( coord_rotate_rad) + tempY * cos(coord_rotate_rad));
	
	lMin_x = (slong)(( pBuf->Faxle ) * rate);
	lMax_x = (slong)(( pBuf->Faxle + 3 ) * rate);
	lMin_y = (slong)(-3 * rate);
	lMax_y = (slong)(3 * rate);

	vertCoord_x[0] = pBuf->Faxle * rate;
	vertCoord_x[1] = (pBuf->Faxle + 1) * rate;
	vertCoord_x[2] = (pBuf->Faxle + 3) * rate;
	vertCoord_x[3] = (pBuf->Faxle + 3) * rate;
	vertCoord_x[4] = (pBuf->Faxle + 1) * rate;
	vertCoord_x[5] = pBuf->Faxle * rate;

	vertCoord_y[0] = (2.6) * rate;
	vertCoord_y[1] = (3.5) * rate;
	vertCoord_y[2] = (4) * rate;
	vertCoord_y[3] = (-4) * rate;
	vertCoord_y[4] = (-3.5) * rate;
	vertCoord_y[5] = (-2.6) * rate;

#if 0
	dbg_printfSync("pnpvert LB[%.2f][%.2f]LC[%.2f][%.2f]LT[%.2f][%.2f]\n" , 
	vertCoord_x[0] , vertCoord_y[0] , vertCoord_x[1]  , vertCoord_y[1] , vertCoord_x[2]  , vertCoord_y[2] );
	dbg_printfSync("pnpvert RT[%.2f][%.2f]RC[%.2f][%.2f]RB[%.2f][%.2f]\n" , 
	vertCoord_x[3] , vertCoord_y[3] , vertCoord_x[4]  , vertCoord_y[4] , vertCoord_x[5]  , vertCoord_y[5] );
#endif	


#if 0
	//dbg_printfSync("pnpvert world[%d][%d]rel[%d][%d] cWorld[%d][%d]\n" , 
	//Src_world_x_new , Src_world_y_new , Src_rel_x_new , Src_rel_y_new , Coord_world_x_new  , Coord_world_y_new );
	dbg_printfSync("pnp[%d] rel[%d][%d]\n" , i , Src_rel_x_new , Src_rel_y_new);
#endif	

	// front wheel center is in the region
	if(((Src_rel_x_new > lMin_x) && (Src_rel_x_new < lMax_x)) && ((Src_rel_y_new > lMin_y) && (Src_rel_y_new < lMax_y)))
	{
		//point 1(LF):
		Src_LF_world_x_new = (slong)(sSrc.vp_rear_wpos_x
			+ ( pBuf->Wheelbase + pBuf->Faxle + pBuf->Fr_kerare) * cos( src_rotate_rad ) * rate
			+ ( pBuf->Width/2 ) * sin( src_rotate_rad ) * rate);
		
		Src_LF_world_y_new = (slong)(sSrc.vp_rear_wpos_y
			- ( pBuf->Wheelbase + pBuf->Faxle + pBuf->Fr_kerare ) * sin( src_rotate_rad ) * rate
			+ ( pBuf->Width/2 ) * cos( src_rotate_rad ) * rate);

	//fx = ( fdx * cosf(fAngle_rad)) - ( fdy * sinf(fAngle_rad)) + (float_t)ptOrigin_pnt->X;
	//fy = ( fdx * sinf(fAngle_rad)) + ( fdy * cosf(fAngle_rad)) + (float_t)ptOrigin_pnt->Y;
	
		//move
		Src_LF_world_x_new = Src_LF_world_x_new - Coord_world_x_new;
		Src_LF_world_y_new = Src_LF_world_y_new - Coord_world_y_new;
			                                                                          
		//rotate
		tempX = Src_LF_world_x_new;
		tempY = Src_LF_world_y_new;
		Src_LF_world_x_new = (slong)(tempX * cos( coord_rotate_rad ) - tempY * sin( coord_rotate_rad ));
		Src_LF_world_y_new = (slong)(tempX * sin( coord_rotate_rad ) + tempY * cos( coord_rotate_rad ));

		nPnpRet = vi_app_uf_PointInPolygon(6, vertCoord_x, vertCoord_y, Src_LF_world_x_new, Src_LF_world_y_new);

		//point 2(RF):
		if(nPnpRet > 0)
		{
			Src_RF_world_x_new = (slong)(sSrc.vp_rear_wpos_x
				+ ( pBuf->Wheelbase + pBuf->Faxle + pBuf->Fr_kerare ) * cos( src_rotate_rad ) * rate
				- ( pBuf->Width/2 ) * sin( src_rotate_rad ) * rate);
			
			Src_RF_world_y_new = (slong)(sSrc.vp_rear_wpos_y
				- ( pBuf->Wheelbase + pBuf->Faxle + pBuf->Fr_kerare ) * sin( src_rotate_rad ) * rate
				- ( pBuf->Width/2 ) * cos( src_rotate_rad ) * rate);
				                                                                          
			//move
			Src_RF_world_x_new = Src_RF_world_x_new - Coord_world_x_new;
			Src_RF_world_y_new = Src_RF_world_y_new - Coord_world_y_new;
			
			//rotate
			tempX = Src_RF_world_x_new;
			tempY = Src_RF_world_y_new;
			Src_RF_world_x_new = (slong)(tempX * cos( coord_rotate_rad ) - tempY * sin( coord_rotate_rad ));
			Src_RF_world_y_new = (slong)(tempX * sin( coord_rotate_rad ) + tempY * cos( coord_rotate_rad ));

			nPnpRet = vi_app_uf_PointInPolygon(6, vertCoord_x, vertCoord_y, Src_RF_world_x_new, Src_RF_world_y_new);
			
			//point 3(LR):
			if(nPnpRet > 0)
			{
				Src_LR_world_x_new = (slong)(sSrc.vp_rear_wpos_x
					+ ( pBuf->Wheelbase ) * cos( src_rotate_rad ) * rate
					+ ( pBuf->Width/2 ) * sin( src_rotate_rad ) * rate);
				
				Src_LR_world_y_new = (slong)(sSrc.vp_rear_wpos_y
					- ( pBuf->Wheelbase ) * sin( src_rotate_rad ) * rate
					+ ( pBuf->Width/2 ) * cos( src_rotate_rad ) * rate);
				
				//move
				Src_LR_world_x_new = Src_LR_world_x_new - Coord_world_x_new;
				Src_LR_world_y_new = Src_LR_world_y_new - Coord_world_y_new;
					                                                                          
				//rotate
				tempX = Src_LR_world_x_new;
				tempY = Src_LR_world_y_new;
				Src_LR_world_x_new = (slong)(tempX * cos( coord_rotate_rad ) - tempY * sin( coord_rotate_rad ));
				Src_LR_world_y_new = (slong)(tempX * sin( coord_rotate_rad ) + tempY * cos( coord_rotate_rad ));

				nPnpRet = vi_app_uf_PointInPolygon(6, vertCoord_x, vertCoord_y, Src_LR_world_x_new, Src_LR_world_y_new);
				
				//point 4(RR):
				if(nPnpRet > 0)
				{
					Src_RR_world_x_new = (slong)(sSrc.vp_rear_wpos_x
						+ ( pBuf->Wheelbase ) * cos( src_rotate_rad ) * rate
						- ( pBuf->Width/2 ) * sin( src_rotate_rad ) * rate);
					
					Src_RR_world_y_new = (slong)(sSrc.vp_rear_wpos_y
						- ( pBuf->Wheelbase ) * sin( src_rotate_rad ) * rate
						- ( pBuf->Width/2 ) * cos( src_rotate_rad ) * rate);
						                                                                          
					//move
					Src_RR_world_x_new = Src_RR_world_x_new - Coord_world_x_new;
					Src_RR_world_y_new = Src_RR_world_y_new - Coord_world_y_new;
					
					//rotate
					tempX = Src_RR_world_x_new;
					tempY = Src_RR_world_y_new;
					Src_RR_world_x_new = (slong)(tempX * cos( coord_rotate_rad ) - tempY * sin( coord_rotate_rad ));
					Src_RR_world_y_new = (slong)(tempX * sin( coord_rotate_rad ) + tempY * cos( coord_rotate_rad ));

					nPnpRet = vi_app_uf_PointInPolygon(6, vertCoord_x, vertCoord_y, Src_RR_world_x_new, Src_RR_world_y_new);

					if(nPnpRet > 0)
					{
						// do nothing
					}
					else
					{
						bRet = FALSE;
					}
				}
				else
				{
					bRet = FALSE;
				}
			}
			else
			{
				bRet = FALSE;
			}
		}
		else
		{
			bRet = FALSE;
		}
		
		if(FALSE == bRet)
		{
			distance = 0;
		}
		else
		{
			lDistanceX = fabs(Src_rel_x_new - ( pBuf->Faxle )* rate);		
			lDistanceY = (slong)fabs(Src_rel_y_new - 0);
			distance = (slong)sqrt(lDistanceX*lDistanceX + lDistanceY*lDistanceY);
		}

		#if 0
			dbg_printfSync("pnp[%d][%d] LT[%d][%d]RT[%d][%d] LB[%d][%d]RB[%d][%d]\n",i,distance,
			Src_LF_world_x_new , Src_LF_world_y_new ,
			Src_RF_world_x_new , Src_RF_world_y_new , 
			Src_LR_world_x_new , Src_LR_world_y_new , 
			Src_RR_world_x_new , Src_RR_world_y_new );
		#endif	
	}
	else
	{
		bRet = FALSE;
	}
	
	/*sprintf(uf_debug_log[i] , "debug[%d][%d] [%f][%f][%f] [%f][%f][%f]\n",Src_rel_x_new,Src_rel_y_new,
		fCoordAngle , cos( coord_rotate_rad ) , sin( coord_rotate_rad ) , 
		fSrcAngle , cos( src_rotate_rad ) , sin( src_rotate_rad ) );
	sprintf(uf_debug_log[i] , "debug[%d,%d][%d,%d][%d,%d] LT[%d][%d]RT[%d][%d] LB[%d][%d]RB[%d][%d]\n",
		Src_rel_x_new , Src_rel_y_new, Src_world_x_new , Src_world_y_new , Coord_world_x_new , Coord_world_y_new , 
		Src_LF_world_x_new , Src_LF_world_y_new ,
		Src_RF_world_x_new , Src_RF_world_y_new , 
		Src_LR_world_x_new , Src_LR_world_y_new , 
		Src_RR_world_x_new , Src_RR_world_y_new );*/

	return distance;
	//Dst_x_new += sCoord.WheelDiameter/2.0 + sCoord.Wheelbase;
}

static slong vi_app_uf_MakeSrcCoord_3h( void )
{
	S_VI_UF_POS							pos;				/* 今回の移動量計算用 */
	schar								i,j;
	double_t							rad = 0.0;
	S_VI_F_COORDINATE					tmp[D_VI_UF_RECT_MAX];		/* (今回世界座標)座標作成一時領域用 */
	S_VI_UF_BU_BUF_T*					pBuf = &pUft->through_plane_buf;
	uint32_t							index = 0, index1=0, index2=0;
	uchar								shiftPosition;
	slong 								rcode;
	S_VI_CM_DATA_TBL 					calib;								/**< キャリブレーション用歪補正テーブル */
	S_VI_COM_CAR_PARAM_TBL*			    car_data = &(vidataP->car_add->car_data);
	slong								lstDistance[E_VI_UF_BU_FRAME_MAX] , minDistance = 0; //, lDistanceSum = 0;
	sint hood_view_capture_threshold = 0;
	double_t	culc_RRR_xxx;
	double_t	culc_angle;
	MM_STATUS rc = E_MM_STATUS_INVALID;
	struct_MM_Data_RC_Recog_Image_Data_Info mm_deadrec;

	memset(&mm_deadrec, 0, (size_t)sizeof(mm_deadrec));
	rc = MM_READ(E_MM_INFO_TYPE_RC, E_MM_DATA_TYPE_RC_RECOG_IMAGE_DATA_INFO, mm_deadrec);
	if( E_MM_STATUS_OK != rc )		/* Codesonar check eliminates warnings */
	{
		dbg_printfSync("[View]vi_app_uf_MakeSrcCoord_3h: E_MM_DATA_TYPE_RC_RECOG_IMAGE_DATA_INFO read fail\n");
		return E_VI_FAILURE;
	}

	calib.calib = E_VI_FLG_OFF;
	calib.calibData = NULL;

	// shift position
	shiftPosition = vi_app_uf_GetShiftPositon();
	if(E_MM_RC_SHIFT_POSITION_R == shiftPosition) 
	{
		dbg_printfSync("[View]vi_app_uf_GetShiftPositon error\n");
		return E_VI_FAILURE;
	}

	for( i = 0; i < E_VI_UF_BU_FRAME_MAX; i ++ )
	{
		lstDistance[i] = vi_app_uf_IsInAvaiableArea(&pBuf->curDeadFR[pBuf->index_captured] , &pBuf->deadrec_info[i] , i);
	}

	for( i = 0; i < E_VI_UF_BU_FRAME_MAX; i ++ )
	{
		if(lstDistance[i] > 0)
		{
			if(minDistance == 0)
			{
				minDistance = lstDistance[i];
				index = i;
			}
			else
			{
				if(lstDistance[i] < minDistance)
				{
					minDistance = lstDistance[i];
					index = i;
				}
			}
			//lDistanceSum += lstDistance[i];
		}
	}

#if 0
	if(lDistanceSum == 0)
	{
		dbg_printfSync("**************************\n");
		for( i = 0; i < E_VI_UF_BU_FRAME_MAX; i ++ )
			dbg_printfSync(uf_debug_log[i]);
		dbg_printfSync("no avalid data :) (:\n");
	}
#endif

	if(index >= pBuf->buf_num)
	{
		dbg_printfSync("[View] no backup through view to use\n");
		return E_VI_FAILURE;	
	}

	//pBuf->index_backup_3h = (pBuf->curr_buf_index + pBuf->buf_num - index)%(pBuf->buf_num);
	pBuf->index_backup_3h = index;
	if(uf_debug_flag[DBG_FLG_DST_COORD]>0)
		{
			if(D_VI_VIN_CH_MAX == pBuf->camera_id[pBuf->index_backup_3h])
			{
				dbg_printfSync("[View]D_VI_VIN_CH_MAX error\n");
				return E_VI_FAILURE;
			}
		}
	if ((mm_deadrec.rc_info[mm_deadrec.index].steering_angle < -400) || (mm_deadrec.rc_info[mm_deadrec.index].steering_angle > 400))
	{
		hood_view_capture_threshold = g_hood_view_capture_threshold_low;
	}
	else
	{
		hood_view_capture_threshold = g_hood_view_capture_threshold_high;
	}

	for(j=0;j<E_VI_UF_BU_FRAME_MAX;j++)
	{
		/* 後輪車軸中心(0,0）原点の座標から、矩形の世界座標→相対座標を計算する */
		(void)vi_app_uf_CalcMyRect_3h( RcgLocalCoord_3h, &pBuf->curDeadFR[pBuf->index_captured], &pBuf->deadrec_info[pBuf->index_backup_3h], SrcScreenCoord_3h);

		/*************Wheelbase分後退（オフセット）させ、領域を90°回転***************/
		if ((compensation_alg_choose == 1) || (compensation_alg_choose == 2))
		{
			pos.pos_x = (car_data->Wheelbase - (double_t)(((double_t)skelton_debug_param) / 100.0f));
		}
		else
		{
			pos.pos_x = car_data->Wheelbase;
			pos.pos_y = 0.0;
		}

//steering_angle
//vehicle_speed
		/* 横補正 */
		if(mm_deadrec.rc_info[mm_deadrec.index].steering_angle < 0.0f){
			/* 舵角が左方向 */
			skelton_yoko_keisu_AAA = skelton_yoko_keisu_AAA_left;
		}
		else{
			/* 舵角が右方向 */
			skelton_yoko_keisu_AAA = skelton_yoko_keisu_AAA_right;
		}

		//1kmph:0.000277778
		if(mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed < 0.0001f){
			skelton_yoko_keisu_AAA = 0.0f;
		}

		culc_angle = mm_deadrec.rc_info[mm_deadrec.index].steering_angle;
		if(culc_angle > 400.0f){culc_angle = 400.0f;}
		else if(culc_angle < -400.0f){culc_angle = -400.0f;}

		/* 指定舵角以上は[横]補正する defult = ±150[deg]*/
		if(fabsf(culc_angle) > skelton_yoko_start_deg){
			/* 補正量 */
			culc_RRR_xxx = (skelton_yoko_keisu_AAA * culc_angle) / 100.0f;
		}
		else{
			culc_RRR_xxx = 0.0f;
		}
		pos.pos_y = culc_RRR_xxx;

		rad = VI_GR_DEG2RAD( -90 );
		pos.sin_yaw = sin( rad );
		pos.cos_yaw = cos( rad );

		/* クリップする自車下領域を計算 */
		for( i = 0; i < D_UF_3H_DST_NUM; i ++ )
		{
			/* 差分から、クリップするSrc座標の領域を計算 */
			vi_app_uf_calcPos( &SrcScreenCoord_3h[i], &SrcScreenCoord_3h[i], &pos );
		}

		if(uf_debug_flag[DBG_FLG_SRC_COORD]>0)
		{
			dbg_printfSync("wld[%d][%d] LT[%f][%f]RT[%f][%f] LB[%f][%f]RB[%f][%f]\n",pBuf->index_backup_3h,pBuf->index_captured,
				SrcScreenCoord_3h[0].X,SrcScreenCoord_3h[0].Y,
				SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X,SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y,
				SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X,SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y,			
				SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].X,SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].Y);
		}
		// calculate through view coordinate
		for( i = 0; i < D_UF_3H_DST_NUM; i ++ )
		{
			rcode = vi_mid_CamDistortion(vidataP->car_add, (uchar)E_VI_LINE_CALC_3D_HOOD, &calib, &SrcScreenCoord_3h[i]);
			if (E_VI_SUCCESS != rcode)
			{
				dbg_printfSync("[View]vi_mid_CamDistortion_3h error\n");
				return E_VI_FAILURE;
			}
		}

		if(uf_debug_flag[DBG_FLG_DST_COORD]>0)
		{	
			dbg_printfSync("src[%d][%d] LT[%f][%f]RT[%f][%f] LB[%f][%f]RB[%f][%f]\n",pBuf->index_backup_3h,j,
				SrcScreenCoord_3h[0].X,SrcScreenCoord_3h[0].Y,
				SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X,SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y,
				SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X,SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y,		
				SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].X,SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].Y);
		}

		if (
			//Hood view left top point judgement
			(SrcScreenCoord_3h[0].X > (float_t)0)
			&&(SrcScreenCoord_3h[0].X < (float_t)E_VI_DISP_LAYOUT_WIDTH_MAX)
			&&(SrcScreenCoord_3h[0].Y > (float_t)0)
			&&(SrcScreenCoord_3h[0].Y < (float_t)(E_VI_DISP_LAYOUT_HEIGHT_MAX - hood_view_capture_threshold))

			//Hood view right top point judgement
			&&(SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X > (float_t)0 )
			&&(SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].X < (float_t)E_VI_DISP_LAYOUT_WIDTH_MAX )
			&&(SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y > (float_t)0 )
			&&(SrcScreenCoord_3h[D_UF_3H_DST_X_PITCH-1].Y < (float_t)(E_VI_DISP_LAYOUT_HEIGHT_MAX - hood_view_capture_threshold))

			//Hood view left bottom point judgement
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X > (float_t)0)
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X < (float_t)E_VI_DISP_LAYOUT_WIDTH_MAX)
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y > (float_t)0)
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].Y < (float_t)(E_VI_DISP_LAYOUT_HEIGHT_MAX - hood_view_capture_threshold))

			//Hood view right bottom point judgement
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].X > (float_t)0)
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].X < (float_t)E_VI_DISP_LAYOUT_WIDTH_MAX)
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].Y > (float_t)0)
			&&(SrcScreenCoord_3h[D_UF_3H_DST_NUM-1].Y < (float_t)(E_VI_DISP_LAYOUT_HEIGHT_MAX - hood_view_capture_threshold)))
		{
			vi_app_uf_CompensationScreen(SrcScreenCoord_3h, &pBuf->index_backup_3h, 
							&pBuf->curDeadFR[pBuf->index_captured], &pBuf->deadrec_info[pBuf->index_backup_3h]);
			break;
		}
		else
		{
			pBuf->index_backup_3h = (pBuf->index_backup_3h - 1 + E_VI_UF_BU_FRAME_MAX) % E_VI_UF_BU_FRAME_MAX;
		}
	}

	if(j == E_VI_UF_BU_FRAME_MAX)
	{
		//dbg_printfSync("[View] no backup through view to use+\n");
		return E_VI_FAILURE;
	}

	return E_VI_SUCCESS;
}

static slong vi_app_uf_CompensationScreen(S_VI_F_COORDINATE* src_local_cnv_pnt, uint32_t* index_backup, const S_VI_UF_DEADREC_INFO_SIMPLE* drec, const S_VI_UF_DEADREC_INFO_SIMPLE* drec_pre)
{
	/*
	* angle1 && angle2: Threshold of the difference in the ego vehicle ang
	* delta: Vehicle angle subtract
	*/ 
	slong angle1 = -720;
	slong angle2 = 720;
	slong delta;
	slong compensation_angle1;
	static uint32_t pre_index = 0xFF;
	double_t compensation_angle_tmp = 0.0;
	schar i_scale = 0;
	S_VI_F_COORDINATE SrcScreenCoord_3h_tmp[D_UF_3H_DST_NUM] = {0};

	/* compensation_alg_choose 
	* 0 -- Rudder angle correction for each frame step after imaging 
	* 1 -- Rudder angle correction for each frame before imaging 	
	* 2 -- both 1 and 2 
	*/
	if ((compensation_alg_choose == 0) || (compensation_alg_choose == 2))
	{
		if (&index_backup == pre_index)
		{
			if (0 == code_switch)
			{
				if (drec_pre->vp_rear_angle - drec->vp_rear_angle != 0)
				{
					compensation_angle_tmp = (drec_pre->vp_rear_angle - drec->vp_rear_angle > 0) 
						? compensation_angle[abs((sint)drec->steering_angle) / 50] : -compensation_angle[abs((sint)drec->steering_angle) / 50];
					pos_rot.sin_yaw = sin(VI_GR_DEG2RAD(compensation_angle_tmp));
					pos_rot.cos_yaw = cos(VI_GR_DEG2RAD(compensation_angle_tmp));
				}
				else
				{
					pos_rot.sin_yaw = sin(VI_GR_DEG2RAD(0));
					pos_rot.cos_yaw = cos(VI_GR_DEG2RAD(0));
				}
			}
			else
			{
				/* 
				* Solve the abnormal screen of large angle compensation 
				* Turn right: vp_rear_angle is reduced from 3600 to 0, and so on. 
				* Turn left: vp_rear_angle is incremented from 0 to 3600, and so on.
				*/
				delta = drec_pre->vp_rear_angle - drec->vp_rear_angle;   /* backup angle minus current angle */
	
				/* Specified compensation angle range */
				compensation_angle1 = (slong)(delta * step_scale_angle);
						
				/* -600 < steering_angle < 600 */
				if ((compensation_angle1 > -16)&& (compensation_angle1 < 16))
				{
					pos_rot.sin_yaw = sin(VI_GR_DEG2RAD(compensation_angle1));
					pos_rot.cos_yaw = cos(VI_GR_DEG2RAD((compensation_angle1)));
				}
			}

			pos_rot.pos_x = src_local_cnv_pnt[rotate_center_switch].X;
			pos_rot.pos_y = src_local_cnv_pnt[rotate_center_switch].Y;

			for (i_scale = 0; i_scale < D_UF_3H_DST_NUM; i_scale++)
			{
				SrcScreenCoord_3h_tmp[i_scale].X = src_local_cnv_pnt[i_scale].X;
				SrcScreenCoord_3h_tmp[i_scale].Y = src_local_cnv_pnt[i_scale].Y;
				src_local_cnv_pnt[i_scale].X = SrcScreenCoord_3h_correct_pre[i_scale].X - step_scale_x * (SrcScreenCoord_3h_pre[i_scale].X - src_local_cnv_pnt[i_scale].X);
				src_local_cnv_pnt[i_scale].Y = SrcScreenCoord_3h_correct_pre[i_scale].Y - step_scale_y * (SrcScreenCoord_3h_pre[i_scale].Y - src_local_cnv_pnt[i_scale].Y);
				SrcScreenCoord_3h_correct_pre[i_scale].X = src_local_cnv_pnt[i_scale].X;    /* Record screen coordinates X after corrected */
				SrcScreenCoord_3h_correct_pre[i_scale].Y = src_local_cnv_pnt[i_scale].Y;    /* Record screen coordinates Y after corrected */

				/* Rotate the skeleton screen according to the data in pos_rot */
				vi_app_uf_calcPos(&src_local_cnv_pnt[i_scale], &src_local_cnv_pnt[i_scale], &pos_rot); 
				src_local_cnv_pnt[i_scale].X = (float_t)(src_local_cnv_pnt[i_scale].X + pos_rot.pos_x);     /* Unified coordinates */
				src_local_cnv_pnt[i_scale].Y = (float_t)(src_local_cnv_pnt[i_scale].Y + pos_rot.pos_y);
				/***************************************************************/
				SrcScreenCoord_3h_pre[i_scale].X = SrcScreenCoord_3h_tmp[i_scale].X;    /* Record screen coordinates X */
				SrcScreenCoord_3h_pre[i_scale].Y = SrcScreenCoord_3h_tmp[i_scale].Y;    /* Record screen coordinates Y */
			}
		}
		else
		{
			pre_index = *index_backup;
			if (0 == code_switch)
			{
				if(drec_pre->vp_rear_angle - drec->vp_rear_angle != 0)
				{
					compensation_angle_tmp = (drec_pre->vp_rear_angle - drec->vp_rear_angle > 0) 
						? compensation_angle[abs((sint)drec->steering_angle) / 50] : -compensation_angle[abs((sint)drec->steering_angle) / 50];
					pos_rot.sin_yaw = sin(VI_GR_DEG2RAD(compensation_angle_tmp));
					pos_rot.cos_yaw = cos(VI_GR_DEG2RAD(compensation_angle_tmp));
				}
				else
				{
					pos_rot.sin_yaw = sin(VI_GR_DEG2RAD(0));
					pos_rot.cos_yaw = cos(VI_GR_DEG2RAD(0));
				}
			}
			else
			{ 
				/* Solve the abnormal screen of large angle compensation */
				/* Turn right: vp_rear_angle is reduced from 3600 to 0, and so on. 
				*  Turn left: vp_rear_angle is incremented from 0 to 3600, and so on.
				*/
				delta = drec_pre->vp_rear_angle - drec->vp_rear_angle;   /* backup angle minus current angle */
		
				/* Specified compensation angle range */
				compensation_angle1 = (slong)(delta * step_scale_angle);
						
				/* -600 < steering_angle < 600 */
				if ((compensation_angle1 > -16)&& (compensation_angle1 < 16))
				{
					pos_rot.sin_yaw = sin(VI_GR_DEG2RAD(compensation_angle1));
					pos_rot.cos_yaw = cos(VI_GR_DEG2RAD((compensation_angle1)));
				}
						
				//pos_rot.sin_yaw = sin(VI_GR_DEG2RAD((delta * step_scale_angle)));
				//pos_rot.cos_yaw = cos(VI_GR_DEG2RAD((delta * step_scale_angle)));
			}
			pos_rot.pos_x = src_local_cnv_pnt[rotate_center_switch].X;
			pos_rot.pos_y = src_local_cnv_pnt[rotate_center_switch].Y;
			//dbg_printfSync("X: %f, Y: %f, sin: %f, cos: %f\n", pos_rot.pos_x, pos_rot.pos_y, pos_rot.sin_yaw, pos_rot.cos_yaw);
			for (i_scale = 0; i_scale < D_UF_3H_DST_NUM; i_scale++)
			{
				SrcScreenCoord_3h_tmp[i_scale].X = src_local_cnv_pnt[i_scale].X;
				SrcScreenCoord_3h_tmp[i_scale].Y = src_local_cnv_pnt[i_scale].Y;
				SrcScreenCoord_3h_correct_pre[i_scale].X = src_local_cnv_pnt[i_scale].X;
				SrcScreenCoord_3h_correct_pre[i_scale].Y = src_local_cnv_pnt[i_scale].Y;
				/* Rotate the skeleton screen according to the data in pos_rot */
				vi_app_uf_calcPos(&src_local_cnv_pnt[i_scale], &src_local_cnv_pnt[i_scale], &pos_rot);
				src_local_cnv_pnt[i_scale].X = (float_t)(src_local_cnv_pnt[i_scale].X + pos_rot.pos_x);
				src_local_cnv_pnt[i_scale].Y = (float_t)(src_local_cnv_pnt[i_scale].Y + pos_rot.pos_y);
				SrcScreenCoord_3h_pre[i_scale].X = SrcScreenCoord_3h_tmp[i_scale].X;    /* Record screen coordinates X */
				SrcScreenCoord_3h_pre[i_scale].Y = SrcScreenCoord_3h_tmp[i_scale].Y;    /* Record screen coordinates Y */
			}
		}
	}
return 0;
}

static slong vi_app_uf_GetLayout_3h( void )
{
	T_IMRLIB_RECT	rc_clip;
	T_IMRLIB_2DPOS	pt_src[D_UF_3H_DST_NUM], pt_dst[D_UF_3H_DST_NUM];
	T_IMRLIB_2DPOS	pitch;//add No762
	T_IMRLIB_2DPOS	num;
	ER_ID dl_id;
	ER_ID dl_id_sub;//dual DL No762
	sshort i;
	//S_VI_TBL_DATA *pTbl = (S_VI_TBL_DATA *)vidataP->tbl_add;
#if 1
	slong eret = E_VI_SUCCESS;
#endif

	/* DSTの幅高さを求める */
	//pitch.X = vi_app_uf_GetDistance(&DstScreenCoord_3h[D_VI_UF_RECT_LB], &DstScreenCoord_3h[D_VI_UF_RECT_RB]);
	//pitch.Y = vi_app_uf_GetDistance(&DstScreenCoord_3h[D_VI_UF_RECT_LB], &DstScreenCoord_3h[D_VI_UF_RECT_LT]);
	
	/* DST領域の変換 */
	for( i = 0; i < D_UF_3H_DST_NUM; i++ )
	{
		//add No762
		pt_dst[i].X = (H)((DstScreenCoord_3h[i].X)*4);
		pt_dst[i].Y = (H)((DstScreenCoord_3h[i].Y)*4);
	}

	/* SRC領域の変換 */
	for( i = 0; i < D_UF_3H_DST_NUM; i++ )
	{
		//add No762
		pt_src[i].X = (H)((SrcScreenCoord_3h[i].X)*4);
		pt_src[i].Y = (H)((SrcScreenCoord_3h[i].Y)*4);
	}

	/* クリップ領域の作成*/
	rc_clip.lt.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-D_UF_3H_DST_X_PITCH].X;	// max area X
	rc_clip.lt.Y = (H)DstScreenCoord_3h[0].Y;										
	rc_clip.rb.X = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].X;
	rc_clip.rb.Y = (H)DstScreenCoord_3h[D_UF_3H_DST_NUM-1].Y;

	/* 頂点数 */
	num.X = D_UF_3H_DST_X_PITCH;
	num.Y = D_UF_3H_DST_Y_PITCH;

	/* DL作成 */
	// for main vsps
	pUft->dl_id = E_VI_MALLOC_FAILURE;
	//pUft->oddYUVaddr = imrlib_getDLYuvCPRAddr(pUft->dl_id);

	/* dual DL No762 */
	//dl_id_sub = imrlib_makeDLAutoMeshDst_Brightness(pt_src, pitch, num, pt_dst[0], &rc_clip );
	//dl_id_sub = imrlib_makeDL_Hilbert(num, pt_src, pt_dst, &rc_clip, OFF);
	//dl_id_sub = imrlib_makeDL_Tile( num, pt_src, pt_dst, &rc_clip, OFF );
	dl_id_sub = imrlib_makeDL( num, pt_src, pt_dst, &rc_clip );
	if( E_VI_MALLOC_FAILURE == dl_id_sub )
	{
		// DL作成失敗。
		ERROR_PRINTF("\n");
		return E_VI_FAILURE;
	}
	else
	{
		if( E_VI_MALLOC_FAILURE != pUft->dl_id_sub )
		{
			imrlib_deleteDL( pUft->dl_id_sub );
			pUft->dl_id_sub = E_VI_MALLOC_FAILURE;
		}
	}
	pUft->dl_id_sub = dl_id_sub;
	
	//pUft->oddYUVaddr = imrlib_getDLYuvCPRAddr(pUft->dl_id_sub);
	/* dual DL No762 */
	//dbg_printfSync("[vi_app_uf_GetLayout]@@@ dl_id = x%x, dl_id_sub = x%x, stats(%d)\n", pUft->dl_id, pUft->dl_id_sub, UfBackup_IGN_Flag);//debug Test
#if 0
		// 輝度補正
		eret = vi_app_uf_bc_regset();
		if( E_VI_SUCCESS != eret )
		{
			// ログ出力のみ。
			ERROR_PRINTF("\n");
		}
#endif

	return E_VI_SUCCESS;
}
static slong vi_app_uf_clearImage( ID mem_bmp_id, ulong val )
{
	Error	memRet;							// memdrvの戻り値
	T_FBMAN_MBITMAP		mem_bmp_info;
	void				* bmp_addr = NULL;

	/* 画像情報を取得 */
	memRet = memdrv_MemBitmapInfoGet( (membmp_id_t)mem_bmp_id, &mem_bmp_info );
	if (Success != memRet)
	{
		dbg_printfSync("[VIEW] vi_clearImage memdrv_MemBitmapInfoGet error memRet=%d mem_bmp_id=%d\n",memRet,mem_bmp_id);
		return E_VI_FAILURE;
	}

	/* 画像アドレスを取得 */
	memRet = memdrv_MemBitmapVirtAddrGet( (membmp_id_t)mem_bmp_id, (void **)&bmp_addr );
	if ( ( Success != memRet ) || ( NULL == bmp_addr ) )
	{
		dbg_printfSync("[VIEW] vi_clearImage memdrv_MemBitmapVirtAddrGet error memRet=%d mem_bmp_id=%d\n",memRet,mem_bmp_id);
		return E_VI_FAILURE;
	}

	/* メモリのゼロクリア */
	/* memsetの第2引数がsinged型なのでキャストが必要。*/
	memset( bmp_addr, (slong)val, mem_bmp_info.Width * mem_bmp_info.Height * mem_bmp_info.bpp / 8 );

	/* キャッシュ吐き出し */
	ManageCaches( (Address)bmp_addr, mem_bmp_info.Width * mem_bmp_info.Height * mem_bmp_info.bpp / 8, ACCESS_DST_COHERENT );


	return E_VI_SUCCESS;
}
slong vi_app_uf_CalcMyRect_3h( const S_VI_F_COORDINATE* rcg_local_pnt, const S_VI_UF_DEADREC_INFO_SIMPLE* drec, const S_VI_UF_DEADREC_INFO_SIMPLE* drec_pre, S_VI_F_COORDINATE* src_local_conv_pnt)
{
	slong nRet = E_VI_SUCCESS;
	sint  nCnt = 0;

	//S_VI_F_COORDINATE str_pnt[D_VI_UF_RECT_MAX];

	S_VI_F_COORDINATE my_pnt;		/* 今回の自車位置の矩形格納用 */
	//S_VI_F_COORDINATE my_pnt_pre;	/* 前回の自車位置の矩形格納用 */
	S_VI_F_COORDINATE wld_pnt;		/* 現在の自車位置の矩形を世界座標に変換する一時格納用変数 */
	S_VI_F_COORDINATE loc_pnt;		/* 現在の自車位置の矩形を相対座標に変換する一時格納用変数 */
	//S_VI_F_COORDINATE view_pnt;	/* 現在の自車位置の矩形をVIEWの座標に変換する一時格納用変数 */
	float_t fYaw;
	
	/* 引数チェック */
	if (( NULL == rcg_local_pnt )
		|| ( NULL == drec )
		|| ( NULL == src_local_conv_pnt )
		)
	{
		return ( E_VI_FAILURE );
	}

	// 今回の自車位置
	my_pnt.X = (float_t)drec->vp_rear_wpos_x;
	my_pnt.Y = (float_t)drec->vp_rear_wpos_y;
	fYaw = (float_t)drec->vp_rear_angle / 10.0f;

	for ( nCnt = 0; nCnt < D_UF_3H_DST_NUM; nCnt++ )
	{
		/*Src領域の世界座標計算 */
		/*（viewの画面座標等の変換の単位は（浮動少数、m）なので、デドレコの座標単位(slong cm)にあわせる）*/
		/* 後輪車軸中心からの座標は計算済みなので、＋するだけ*/
		src_local_conv_pnt[nCnt].X = my_pnt.X + (float_t)(rcg_local_pnt[nCnt].X * 100.0F);
		src_local_conv_pnt[nCnt].Y = my_pnt.Y + (float_t)(rcg_local_pnt[nCnt].Y * 100.0F);
		
		/* 自車位置座標を中心に回転した座標の演算 */
		nRet = vi_app_uf_Math_CalcRotatePoint( &my_pnt, &(src_local_conv_pnt[nCnt]), fYaw, &wld_pnt );
		if ( E_VI_SUCCESS != nRet )
		{	
			return ( nRet );
		}
		
		/* 世界座標を、前回の自車位置情報（前回表示時のデドレコ情報）を使用して相対座標に変換する */
		vi_app_uf_Math_WldToLoc_point(&wld_pnt, drec_pre, &loc_pnt);

		/* 単位を元に戻す*/
		src_local_conv_pnt[nCnt].X = loc_pnt.X / 100.0F;
		src_local_conv_pnt[nCnt].Y = loc_pnt.Y / 100.0F;

		src_local_conv_pnt[nCnt].X = src_local_conv_pnt[nCnt].X;
		src_local_conv_pnt[nCnt].Y = -src_local_conv_pnt[nCnt].Y;		
		
	}

	return ( E_VI_SUCCESS );
}
slong vi_app_uf_deadrecinfoFR(uint32_t buf_index)
{
	MM_STATUS rc = E_MM_STATUS_INVALID;
	struct_MM_Data_RC_Recog_Image_Data_Info mm_deadrec;
	SYSTIM CurrentTime;
    sint i = 0;
	double d_correct_pos_x;
	double d_correct_pos_y;
	slong  d_correct_angle;
	static float_t vp_rear_wpos_x_pre = 0.0;
	static float_t vp_rear_wpos_y_pre = 0.0;
	static UW time_pre = 0;
	static const float_t SPEED_SCALE_FACTOR = 0.8;
	static float_t trip_pre = 0.0;
	float_t vp_rear_wpos_x_delta = 0.0;
	float_t vp_rear_wpos_y_delta = 0.0;
	float_t trip_delta = 0.0;
	slong temp_curr = 0;
	slong temp_pre = 0;
	static float_t trip_read_pre = 0.0;
	static slong vp_sps_wpos_x_read_pre = 0;
	static slong vp_sps_wpos_y_read_pre = 0;
	
	/* 共有OBJより取得 */
	memset(&mm_deadrec, 0, (size_t)sizeof(mm_deadrec));
	rc = MM_READ(E_MM_INFO_TYPE_RC, E_MM_DATA_TYPE_RC_RECOG_IMAGE_DATA_INFO, mm_deadrec);
	if (E_MM_STATUS_OK != rc) {
		/* エラーログ */
	}

	pUft->through_plane_buf.index_captured = buf_index;

	// get the previous one index of vehicle location information
	i = (mm_deadrec.index + E_RCMM_INDEX_MAX - 1) % E_RCMM_INDEX_MAX;  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, ...
	
	cl_get_tim(&CurrentTime);
	pUft->through_plane_buf.curDeadFR[buf_index].Time =  CurrentTime;
		
	if ((mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_x != 0) && (mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_x != vp_sps_wpos_x_read_pre))
	{
		vp_rear_wpos_x_delta = (float_t)((CurrentTime.ltime - mm_deadrec.rc_info[mm_deadrec.index].tim.ltime)
							* mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed 
							* SPEED_SCALE_FACTOR 
							* cos(CMN_DEG2RAD_F_F32((float_t)mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle/10.0)) / 36.0);
		pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_x = (slong)(vp_rear_wpos_x_delta + (float_t)mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_x);
			
	}
	else
	{
		vp_rear_wpos_x_delta = (float_t)((CurrentTime.ltime - time_pre)
							* mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed
							* SPEED_SCALE_FACTOR
							* cos(CMN_DEG2RAD_F_F32((float_t)mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle/10.0)) / 36.0);
		pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_x = (slong)(vp_rear_wpos_x_delta + vp_rear_wpos_x_pre);
	}
	vp_rear_wpos_x_pre = pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_x;
	
	if ((mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_y != 0) && (mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_y != vp_sps_wpos_y_read_pre))
	{
		vp_rear_wpos_y_delta = (float_t)((CurrentTime.ltime - mm_deadrec.rc_info[mm_deadrec.index].tim.ltime)
							* mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed
							* SPEED_SCALE_FACTOR
							* sin(CMN_DEG2RAD_F_F32((float_t)mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle/10.0)) / 36.0);
		pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_y = (slong)(vp_rear_wpos_y_delta + (float_t)mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_y);
	}
	else
	{
		vp_rear_wpos_y_delta = (float_t)((CurrentTime.ltime - time_pre)
							* mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed
							* SPEED_SCALE_FACTOR
							* sin(CMN_DEG2RAD_F_F32((float_t)mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle/10.0)) / 36.0);
		pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_y = (slong)(vp_rear_wpos_y_delta + vp_rear_wpos_y_pre);
	}
	vp_rear_wpos_y_pre = pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_y;
	pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_angle = (slong)(((float_t)(CurrentTime.ltime - mm_deadrec.rc_info[mm_deadrec.index].tim.ltime)
																	/(float_t)(mm_deadrec.rc_info[mm_deadrec.index].tim.ltime -  mm_deadrec.rc_info[i].tim.ltime)
																	*(mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle - mm_deadrec.rc_info[i].vp_sps_angle)
																	)+mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle);
	trip_delta = (float_t)(10.0 * sqrt((vp_rear_wpos_x_delta * vp_rear_wpos_x_delta + vp_rear_wpos_y_delta * vp_rear_wpos_y_delta)));

	temp_pre = (slong)(trip_read_pre * 10);
	temp_curr = (slong)(mm_deadrec.rc_info[mm_deadrec.index].trip * 10.0);
	if (temp_curr != temp_pre)
	{
		pUft->through_plane_buf.curDeadFR[buf_index].trip = trip_delta + mm_deadrec.rc_info[mm_deadrec.index].trip;
	}
	else
	{
		pUft->through_plane_buf.curDeadFR[buf_index].trip = trip_delta + trip_pre;
	}
	trip_pre = pUft->through_plane_buf.curDeadFR[buf_index].trip;
	time_pre = CurrentTime.ltime;
	/* Record rear center coordinate and trip read from memory when capturing frame */
	vp_sps_wpos_x_read_pre = mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_x;
	vp_sps_wpos_y_read_pre = mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_y;
	trip_read_pre= mm_deadrec.rc_info[mm_deadrec.index].trip;

	pUft->through_plane_buf.curDeadFR[buf_index].trip /= 10.0f;
	pUft->through_plane_buf.curDeadFR[buf_index].steering_angle = mm_deadrec.rc_info[mm_deadrec.index].steering_angle ;
	pUft->through_plane_buf.curDeadFR[buf_index].Time.ltime = CurrentTime.ltime;

	if(uf_debug_flag[DBG_FLG_DEADRECO] > 0)
	{
		dbg_printfSync("**before-%d: (%d,%d,%d),%f,%f\n", CurrentTime.ltime, 
					mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_x, mm_deadrec.rc_info[mm_deadrec.index].vp_sps_wpos_y, mm_deadrec.rc_info[mm_deadrec.index].vp_sps_angle, 
					mm_deadrec.rc_info[mm_deadrec.index].trip, mm_deadrec.rc_info[mm_deadrec.index].vehicle_speed);

		dbg_printfSync("**after-%d-%d: (%f,%f,%d),%f\n", CurrentTime.ltime, mm_deadrec.rc_info[mm_deadrec.index].tim.ltime,
					pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_x, pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_y, pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_angle,
					pUft->through_plane_buf.curDeadFR[buf_index].trip);
	}
	
	
	/*if(uf_debug_flag[DBG_FLG_DEADRECO] > 0)
	{
		dbg_printfSync("[vi_app_uf_deadrecinfoFR]### [%d] (%d,%d)(%d)(%f) ###\n", buf_index,
			pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_x,
			pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_wpos_y,
			pUft->through_plane_buf.curDeadFR[buf_index].vp_rear_angle,
			pUft->through_plane_buf.curDeadFR[buf_index].trip);
	}	*/
	return E_VI_SUCCESS;
}

